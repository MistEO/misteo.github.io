<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>肝！</title>
  
  <subtitle>我爱学习！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.misteo.top/"/>
  <updated>2020-11-30T13:16:19.080Z</updated>
  <id>http://www.misteo.top/</id>
  
  <author>
    <name>MistEO</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>std::unique_ptr使用incomplete type的报错分析和解决</title>
    <link href="http://www.misteo.top/2020/11/30/std-unique-ptr%E4%BD%BF%E7%94%A8incomplete-type%E7%9A%84%E6%8A%A5%E9%94%99%E5%88%86%E6%9E%90%E5%92%8C%E8%A7%A3%E5%86%B3/"/>
    <id>http://www.misteo.top/2020/11/30/std-unique-ptr使用incomplete-type的报错分析和解决/</id>
    <published>2020-11-30T03:31:17.000Z</published>
    <updated>2020-11-30T13:16:19.080Z</updated>
    
    <content type="html"><![CDATA[<p><code>Pimpl</code>(Pointer to implementation)很多同学都不陌生，但是从原始指针升级到C++11的独占指针<code>std::unique_ptr</code>时，会遇到一个<code>incomplete type</code>的报错，本文来分析一下报错的原因以及分享几种解决方法~</p><a id="more"></a><h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>首先举一个传统C++中的<code>Pimpl</code>的例子</p><pre><code class="c++">// widget.h// 预先声明class Impl;class Widget{    Impl * pImpl;};</code></pre><p>很简单，没什么问题，但是使用的是原始指针，现在我们升级到<code>std::unique_ptr</code></p><pre><code class="c++">// widget.h// 预先声明class Impl;class Widget{    std::unique_ptr&lt;Impl&gt; pImpl;};</code></pre><p>很简单的一次升级，而且也能通过编译，看似也没问题，但当你创建一个<code>Widget</code>的实例</p><pre><code class="C++">// pimpl.cpp#include &quot;widget.h&quot;Widget w;</code></pre><p>这时候，问题来了</p><pre><code class="bash">$ g++ pimpl.cppIn file included from /usr/include/c++/9/memory:80,    from widget.h:1,    from pimpl.cpp:1:/usr/include/c++/9/bits/unique_ptr.h:    In instantiation of ‘void std::default_delete&lt;_Tp&gt;::operator()(_Tp*) const [with _Tp = Impl]’:/usr/include/c++/9/bits/unique_ptr.h:292:17:    required from ‘std::unique_ptr&lt;_Tp, _Dp&gt;::~unique_ptr() [with _Tp = Impl; _Dp = std::default_delete&lt;Impl&gt;]’widget.h:5:7:   required from here/usr/include/c++/9/bits/unique_ptr.h:79:16: error: invalid application of ‘sizeof’ to incomplete type ‘Impl’79 |  static_assert(sizeof(_Tp)&gt;0,   |                ^~~~~~~~~~~</code></pre><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>从报错我们可以看出，<code>std::unique_ptr</code>中需要静态检测类型的大小<code>static_assert(sizeof(Impl)&gt;0</code>，但是我们的<code>Impl</code>是一个预先声明的类型，是<code>incomplete type</code>，也就没法计算，所以导致报错。</p><p>想要知道怎么解决，首先需要知道<code>std::unique_ptr</code>为啥需要计算这个，我们来看一下STL中相关的源码，从报错中得知是<code>unique_ptr.h</code>的292行，调用了79行，我们把前后相关源码都粘出来（来自<code>g++ 9.3.0</code>中的实现）</p><pre><code class="c++">// 292行附近      /// Destructor, invokes the deleter if the stored pointer is not null.      ~unique_ptr() noexcept      {    static_assert(__is_invocable&lt;deleter_type&amp;, pointer&gt;::value,              &quot;unique_ptr&#39;s deleter must be invocable with a pointer&quot;);    auto&amp; __ptr = _M_t._M_ptr();    if (__ptr != nullptr)// 292行在这里      get_deleter()(std::move(__ptr));    __ptr = pointer();      }// 79行附近  /// Primary template of default_delete, used by unique_ptr  template&lt;typename _Tp&gt;    struct default_delete    {      /// Default constructor      constexpr default_delete() noexcept = default;      /** @brief Converting constructor.       *       * Allows conversion from a deleter for arrays of another type, @p _Up,       * only if @p _Up* is convertible to @p _Tp*.       */      template&lt;typename _Up, typename = typename           enable_if&lt;is_convertible&lt;_Up*, _Tp*&gt;::value&gt;::type&gt;        default_delete(const default_delete&lt;_Up&gt;&amp;) noexcept { }      /// Calls @c delete @p __ptr      void      operator()(_Tp* __ptr) const      {    static_assert(!is_void&lt;_Tp&gt;::value,              &quot;can&#39;t delete pointer to incomplete type&quot;);// 79行在这里    static_assert(sizeof(_Tp)&gt;0,              &quot;can&#39;t delete pointer to incomplete type&quot;);    delete __ptr;      }    };</code></pre><p><code>std::unique_ptr</code>中的析构函数，调用了默认的删除器<code>default_delete</code>，而<code>default_delete</code>中检查了<code>Impl</code>，其实就算<code>default_delete</code>中不检查，到下一步<code>delete __ptr;</code>，还是会出问题，因为不完整的类型无法被<code>delete</code>。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>原因已经知道了，那么解决方法就呼之欲出了，这里提供三种解决方法：</p><ul><li><a href="#方法一">方法一</a>：改用<code>std::shared_ptr</code></li><li><a href="#方法二">方法二</a>：自定义删除器，将<code>delete pImpl</code>的操作，放到<code>widget.cpp</code>源文件中</li><li><a href="#方法三">方法三</a>：仅声明<code>Widget</code>的析构函数，但不要在<code>widget.h</code>头文件中实现它</li></ul><p>其中我最推荐方法三，它不改变代码需求，且仅做一点最小的改动，下面依次分析</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p><strong>改用<code>std::shared_ptr</code></strong></p><pre><code class="c++">// widget.h// 预先声明class Impl;class Widget{    std::shared_ptr&lt;Impl&gt; pImpl;};</code></pre><p>改完就能通过编译了，这种改法最简单。但是缺点也很明显：使用<code>shared_ptr</code>可能会改变项目的需求，<code>shared_ptr</code>也会带来额外的性能开销，而且违反了“尽可能使用<code>unique_ptr</code>而不是<code>shared_ptr</code>”的原则（当然这个原则是我编的，哈哈）</p><p>那为什么<code>unique_ptr</code>不能使用预先声明的<code>imcomplete type</code>，但是<code>shared_ptr</code>却可以？</p><p>因为对于<code>unique_ptr</code>而言，删除器是类型的一部分：</p><pre><code class="c++">  template&lt;typename _Tp, typename _Dp&gt;    class unique_ptr&lt;_Tp[], _Dp&gt;</code></pre><p>这里的<code>_Tp</code>是<code>element_type</code>，<code>_Dp</code>是<code>deleter_type</code></p><p>而<code>shared_ptr</code>却不是这样：</p><pre><code class="c++">  template&lt;typename _Tp&gt;    class shared_ptr : public __shared_ptr&lt;_Tp&gt;</code></pre><p>那为什么<code>unique_ptr</code>的删除器是类型的一部分，而<code>shared_ptr</code>不是呢？</p><p>答案是设计如此！哈哈，说了句废话。具体来说，删除器不是类型的一部分，使得你可以对同一种类型的<code>shared_ptr</code>，使用不同的自定义删除器</p><pre><code class="c++">auto my_deleter = [](Impl * p) {...};std::shared_ptr&lt;Impl&gt; w1(new Impl, my_deleter);std::shared_ptr&lt;Impl&gt; w2(new Impl); // default_deleterw1 = w2; // It&#39;s OK!</code></pre><p>看到了么，这里的两个智能指针<code>w1</code>和<code>w2</code>，虽然使用了不同的删除器，但他们是同一种类型，可以相互进行赋值等等操作。而<code>unique_ptr</code>却不能这么玩</p><pre><code class="c++">auto my_deleter = [](Impl * p) {...};std::unique_ptr&lt;Impl, decltype(my_deleter)&gt; w1(new Impl, my_deleter);std::unique_ptr&lt;Impl&gt; w2(new Impl); // default_deleter// w1的类型是 std::unique_ptr&lt;Impl, lambda []void (Impl *p)-&gt;void&gt;// w2的类型是 std::unique_ptr&lt;Impl, std::default_delete&lt;Impl&gt;&gt;w1 = std::move(w2); // 错误！类型不同，没有重载operator=</code></pre><p>道理我都明白了，那为什么要让这两种智能指针有这样的区别啊？</p><p>答案还是设计如此！哈哈，具体来说<code>unique_ptr</code>本身就只是对原始指针的简单封装，这样做不会带来额外的性能开销。而<code>shared_ptr</code>的实现提高了灵活性，但却进一步增大了性能开销。针对不同的使用场景所以有这样的区别。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p><strong>自定义删除器，将<code>delete pImpl</code>的操作，放到<code>widget.cpp</code>源文件中</strong></p><pre><code class="c++">// widget.h// 预先声明class Impl;class Widget{    struct ImplDeleter final    {        constexpr ImplDeleter() noexcept = default;        void operator()(Impl *p) const;    };    std::unique_ptr&lt;Impl, ImplDeleter&gt; pImpl = nullptr;};</code></pre><p>然后在源文件<code>widget.cpp</code>中</p><pre><code class="c++">#include &quot;widget.h&quot;#include &quot;impl.h&quot;void Widget::ImplDeleter::operator()(Impl *p) const{    delete p;}</code></pre><p>这种方法改起来也不复杂，但是弊端也很明显，<code>std::make_unique</code>没法使用了，只能自己手动<code>new</code>，直接看源码吧</p><pre><code class="c++">  template&lt;typename _Tp, typename... _Args&gt;    inline typename _MakeUniq&lt;_Tp&gt;::__single_object    make_unique(_Args&amp;&amp;... __args)    { return unique_ptr&lt;_Tp&gt;(new _Tp(std::forward&lt;_Args&gt;(__args)...)); }</code></pre><p>看出问题在哪了么？这里返回的是默认删除器类型的<code>unique_ptr</code>，即<code>std::unique_ptr&lt;Impl, std::default_delete&lt;Impl&gt;&gt;</code>，如<a href="#方法一">方法一</a>中所说，是不同删除器类型的<code>unique_ptr</code>是没法相互赋值的，也就是说：</p><pre><code class="c++">pImpl = std::make_unique&lt;Impl&gt;(); // 错误！类型不同，没有重载operator=pImpl = std::unique_ptr&lt;Impl, ImplDeleter&gt;(new Impl); // 正确！每次你都要写这么一大串</code></pre><p>当然你也可以实现一个<code>make_impl</code>，并且<code>using</code>一下这个很长的类型，比如：</p><pre><code class="c++">using unique_impl = std::unique_ptr&lt;Impl, ImplDeleter&gt;;template&lt;typename... Ts&gt;unique_impl make_impl(Ts &amp;&amp; ...args){    return unique_impl(new Impl(std::forward&lt;Ts&gt;(args)...));}// 调用pImpl = make_impl();</code></pre><p>看似还凑合，但总的来说，这样做还是感觉很麻烦。并且有一个很头疼的问题：<code>make_impl</code>作为函数模板，没法声明和定义分离，而且其中的用到了<code>new</code>，需要完整的<code>Impl</code>类型。所以，你只能把这一段模板函数写在源文件中，emmm，总感觉不太对劲。</p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p><strong>仅声明<code>Widget</code>的析构函数，但不要在<code>widget.h</code>头文件中实现它</strong></p><pre><code class="c++">// widget.h// 预先声明class Impl;class Widget{    Widget();    ~Widget();  // 仅声明    std::unique_ptr&lt;Impl&gt; pImpl;};</code></pre><pre><code class="c++">// widget.cpp#include &quot;widget.h&quot;#include &quot;impl.h&quot;Widget::Widget()    : pImpl(nullptr){}Widget::~Widget() = default;    // 在这里定义</code></pre><p>这样就解决了！是不是出乎意料的简单！并且你也可以正常的使用<code>std::make_unique</code>来进行赋值。唯一的缺点就是你没法在头文件中初始化<code>pImpl</code>了</p><p>但也有别的问题，因为不光是析构函数中需要析构<code>std::unique_ptr</code>，还有别的也需要，比如移动构造、移动运算符等。所以在移动构造、移动运算符中，你也会遇到同样的编译错误。解决方法也很简单，同上面一样：</p><pre><code class="c++">// widget.h// 预先声明class Impl;class Widget{    Widget();    ~Widget();    Widget(Widget &amp;&amp; rhs);  // 同析构函数，仅声明    Widget&amp; operator=(Widget&amp;&amp; rhs);    std::unique_ptr&lt;Impl&gt; pImpl;};</code></pre><pre><code class="c++">// widget.cpp#include &quot;widget.h&quot;#include &quot;impl.h&quot;Widget::Widget()    : pImpl(nullptr){}Widget::~Widget() = default;Widget(Widget&amp;&amp; rhs) = default;             //在这里定义Widget&amp; operator=(Widget&amp;&amp; rhs) = default;</code></pre><p>搞定！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/4.SmartPointers/item22.md" target="_blank" rel="noopener">当使用Pimpl惯用法，请在实现文件中定义特殊成员函数 -<br>《Effective Modern Cpp》</a></li><li><a href="https://stackoverflow.com/questions/9954518/stdunique-ptr-with-an-incomplete-type-wont-compile/9954553" target="_blank" rel="noopener">std::unique_ptr with an incomplete type won’t compile - Stack Overflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Pimpl&lt;/code&gt;(Pointer to implementation)很多同学都不陌生，但是从原始指针升级到C++11的独占指针&lt;code&gt;std::unique_ptr&lt;/code&gt;时，会遇到一个&lt;code&gt;incomplete type&lt;/code&gt;的报错，本文来分析一下报错的原因以及分享几种解决方法~&lt;/p&gt;
    
    </summary>
    
    
      <category term="C/C++" scheme="http://www.misteo.top/tags/C-C/"/>
    
      <category term="STL" scheme="http://www.misteo.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>安全的字符串拷贝strcpy_s的实现与理解</title>
    <link href="http://www.misteo.top/2020/10/21/%E5%AE%89%E5%85%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9Dstrcpy-s%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%90%86%E8%A7%A3/"/>
    <id>http://www.misteo.top/2020/10/21/安全的字符串拷贝strcpy-s的实现与理解/</id>
    <published>2020-10-21T07:29:00.000Z</published>
    <updated>2020-11-30T13:16:04.436Z</updated>
    
    <content type="html"><![CDATA[<p>在C标准库中提供了字符串拷贝函数<code>strcpy</code>，而微软则为为它提供了一个更安全的版本<code>strcpy_s</code>，其函数原型为</p><pre><code class="c++">errno_t __cdecl strcpy_s(    char*       _Destination,    rsize_t     _SizeInBytes,    char const* _Source    );</code></pre><p>分享下它的实现和一些个人理解</p><a id="more"></a><h2 id="源码展示"><a href="#源码展示" class="headerlink" title="源码展示"></a>源码展示</h2><h3 id="标准strcpy的实现"><a href="#标准strcpy的实现" class="headerlink" title="标准strcpy的实现"></a>标准<code>strcpy</code>的实现</h3><pre><code class="c++">// from gcc-4.8.5extern void abort (void);extern int inside_main;__attribute__ ((__noinline__))char *strcpy (char *d, const char *s){  char *r = d;#if defined __OPTIMIZE__ &amp;&amp; !defined __OPTIMIZE_SIZE__  if (inside_main)    abort ();#endif  while ((*d++ = *s++));  return r;}// 简化一下char *strcpy (char *d, const char *s){  char *r = d;  while ((*d++ = *s++));  return r;}</code></pre><p><del>没什么好说的，懂得都懂（笑</del></p><p>逐地址拷贝，当<code>*d == &#39;\0&#39;</code>时，while循环退出结束拷贝，网上搜strcpy实现应该能找到很多详解，不赘述了</p><h3 id="微软strcpy-s的实现"><a href="#微软strcpy-s的实现" class="headerlink" title="微软strcpy_s的实现"></a>微软<code>strcpy_s</code>的实现</h3><pre><code class="c++">// from C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\crt\src\tcscpy_s.inl/****tcscpy_s.inl - general implementation of _tcscpy_s**       Copyright (c) Microsoft Corporation. All rights reserved.**Purpose:*       This file contains the general algorithm for strcpy_s and its variants.*****/_FUNC_PROLOGUEerrno_t __cdecl _FUNC_NAME(_CHAR *_DEST, size_t _SIZE, const _CHAR *_SRC){    _CHAR *p;    size_t available;    /* validation section */    _VALIDATE_STRING(_DEST, _SIZE);    _VALIDATE_POINTER_RESET_STRING(_SRC, _DEST, _SIZE);    p = _DEST;    available = _SIZE;    while ((*p++ = *_SRC++) != 0 &amp;&amp; --available &gt; 0)    {    }    if (available == 0)    {        _RESET_STRING(_DEST, _SIZE);        _RETURN_BUFFER_TOO_SMALL(_DEST, _SIZE);    }    _FILL_STRING(_DEST, _SIZE, _SIZE - available + 1);    _RETURN_NO_ERROR;}</code></pre><p>首先明确一点，多出来的参数<code>size_t _SIZE</code>需要传入目的地址可用长度，即<code>_DEST</code>的可用长度</p><p>实现中多了几个宏定义，我们先<strong>猜一下</strong>他们是干嘛的，然后带着疑问往下看。</p><p>不感兴趣的同学也可以跳过这一章，直接看后面的<a href="#分析结论">分析结论</a></p><h2 id="详细分析过程"><a href="#详细分析过程" class="headerlink" title="详细分析过程"></a>详细分析过程</h2><p>（<em>注：以下为猜测内容，与实际可能有较大差异，正确解释请接着往后看每个宏定义的详细分析</em>）</p><h3 id="总体猜测"><a href="#总体猜测" class="headerlink" title="总体猜测"></a>总体猜测</h3><ul><li><code>_VALIDATE_STRING</code>：应该是验证字符串的合法性，是否为NULL，失败可能会直接return错误码；传入SIZE可能还会判断目的地址是否有这么长？但是这个咋判断呢，想不通</li><li><code>_VALIDATE_POINTER_RESET_STRING</code>：看不懂，不过既然是VALIDATE（验证），估计还是做一些什么检查之类的吧，但是后面为啥又RESET呢？</li><li><code>_RESET_STRING</code>：应该是将字符串重置，重置为NULL么？</li><li><code>_RETURN_BUFFER_TOO_SMALL</code>：应该就是return了一个错误码吧，可能还包含错误信息啥的？</li><li><code>_FILL_STRING</code>：应该是将字符串剩余部分填充为NULL？</li><li><code>_RETURN_NO_ERROR</code>：应该就是<code>return 0</code>。</li></ul><p>这样再看一遍代码下来，整体逻辑还是比较清晰的：</p><ol><li>先两个<code>_VALIDATE</code>宏，验证目的字符串和源字符串的合法性</li><li>开始逐字符拷贝，如果正常拷到<code>&#39;\0&#39;</code>，或者<code>available</code>跑完了，就停止</li><li>如果2.中是<code>available</code>跑完了，说明SRC的长度超过了SIZE，即超过了目的字符串最大可用长度。拷贝失败了，重置DEST，整理错误信息，return错误码。</li><li>正常拷到<code>&#39;\0&#39;</code>，就把DEST剩余的后半部分<code>[_SIZE - available + 1, _Size)</code>全填充为某个比较安全的值。</li><li>return 0 结束。</li></ol><p>下面逐个分析下这些宏，为了便于理解，我整理了一下，不要在意定义的先后顺序~</p><h3 id="VALIDATE-STRING"><a href="#VALIDATE-STRING" class="headerlink" title="_VALIDATE_STRING"></a><code>_VALIDATE_STRING</code></h3><pre><code class="c++">_VALIDATE_STRING(_DEST, _SIZE);// from internal_securecrt.h#define _VALIDATE_STRING(_String, _Size) \    _VALIDATE_STRING_ERROR((_String), (_Size), EINVAL)</code></pre><p>得，套娃，我们接着看</p><pre><code class="c++">// from internal_securecrt.h#define _VALIDATE_STRING_ERROR(_String, _Size, _Ret) \    _VALIDATE_RETURN((_String) != NULL &amp;&amp; (_Size) &gt; 0, EINVAL, (_Ret))// from errno.h#define EINVAL          22</code></pre><p>似乎好理解一点了，如果不满足<code>(_String) != NULL &amp;&amp; (_Size) &gt; 0</code>，可能会报错并返回<code>EINVAL</code>，<code>EINVAL</code>就是errno的错误码<code>22</code>，表示非法参数。原来Size只是判断是否大于0啊，那看来前面猜测的判断DEST长度是猜错了，确实没法实现这个</p><p>但是<code>_VALIDATE_RETURN</code>的第二个和第三个参数都是<code>EINVAL</code>，又是干啥的？</p><pre><code class="c++">// from internal.h#ifndef _VALIDATE_RETURN#define _VALIDATE_RETURN( expr, errorcode, retexpr )                           \    {                                                                          \        int _Expr_val=!!(expr);                                                \        _ASSERT_EXPR( ( _Expr_val ), _CRT_WIDE(#expr) );                       \        if ( !( _Expr_val ) )                                                  \        {                                                                      \            errno = errorcode;                                                 \            _INVALID_PARAMETER(_CRT_WIDE(#expr) );                             \            return ( retexpr );                                                \        }                                                                      \    }#endif  /* _VALIDATE_RETURN */</code></pre><p>首先看明白了上面的疑问，第一个参数<code>expr</code>是判断条件，第二个参数<code>errorcode</code>是赋值给errno的（不了解errno的同学可以自行搜一下），第三个参数<code>retexpr</code>是用来return的</p><p>然后我们接着来看套娃</p><pre><code class="c++">// from crtdbg.h#ifndef _DEBUG    #ifndef _ASSERT_EXPR        #define _ASSERT_EXPR(expr, msg) ((void)0)    #endif  #else // ^^^ !_DEBUG ^^^ // vvv _DEBUG vvv //    // !! is used to ensure that any overloaded operators used to evaluate expr    // do not end up at &amp;&amp;.    #ifndef _ASSERT_EXPR        #define _ASSERT_EXPR(expr, msg) \            (void)(                                                                                     \                (!!(expr)) ||                                                                           \                (1 != _CrtDbgReportW(_CRT_ASSERT, _CRT_WIDE(__FILE__), __LINE__, NULL, L&quot;%ls&quot;, msg)) || \                (_CrtDbgBreak(), 0)                                                                     \            )    #endif</code></pre><p>非Debug模式下，就什么也不做，直接转<code>((void)0)</code>；Debug模式下，<code>_CrtDbgReportW</code>是弹出对话框报错，<code>_CrtDbgBreak</code>是触发调试断点，这个扯远了，不再深度展开，有兴趣的同学再另外看下吧~</p><pre><code class="c++">// from internal.h#define _INVALID_PARAMETER(expr) _CALL_INVALID_PARAMETER(expr)// from internal.h#define _CALL_INVALID_PARAMETER(expr) _invalid_parameter(expr, __FUNCTIONW__, __FILEW__, __LINE__, 0)</code></pre><p><code>_INVALID_PARAMETER</code>说实话我真没太看明白在干嘛，继续追踪后来会到<code>invarg.c</code>中，套娃套的太多了，看不过来了。。获取了<code>__FUNCTION__</code>、<code>__LINE__</code>等，估计是记录错误，可能在VS的调试器等中有体现，有兴趣的同学也自行也就看下吧</p><h4 id="小结（-VALIDATE-STRING）"><a href="#小结（-VALIDATE-STRING）" class="headerlink" title="小结（-VALIDATE-STRING）"></a>小结（-VALIDATE-STRING）</h4><p>总结一下，就是检查<code>(_DEST != NULL &amp;&amp; _Size &gt; 0)</code>，不满足的话，赋值errno，并直接返回错误码，（_DEBUG模式下，还会弹窗提示，并触发调试断点）。简单实现如下</p><pre><code class="c++">// Same like _VALIDATE_STRING(_DEST, _SIZE);if (_DEST == NULL || _Size &lt;= 0){    errno = EINVAL;    return EINVAL;}</code></pre><p>看完了第一个宏，想必对这些宏的套路也有一些了解，后面的就不每个这么详细展开了</p><h3 id="VALIDATE-POINTER-RESET-STRING"><a href="#VALIDATE-POINTER-RESET-STRING" class="headerlink" title="_VALIDATE_POINTER_RESET_STRING"></a><code>_VALIDATE_POINTER_RESET_STRING</code></h3><pre><code class="c++">_VALIDATE_POINTER_RESET_STRING(_SRC, _DEST, _SIZE);// from internal_securecrt.h#define _VALIDATE_POINTER_RESET_STRING(_Pointer, _String, _Size) \    _VALIDATE_POINTER_RESET_STRING_ERROR((_Pointer), (_String), (_Size), EINVAL)// from internal_securecrt.h#define _VALIDATE_POINTER_RESET_STRING_ERROR(_Pointer, _String, _Size, _Ret) \    if ((_Pointer) == NULL) \    { \        _RESET_STRING((_String), (_Size)); \        _VALIDATE_POINTER_ERROR_RETURN((_Pointer), EINVAL, (_Ret)) \    }</code></pre><p>如果<code>_SRC</code>为<code>NULL</code>，才进行<code>_RESET_STRING</code>和<code>_VALIDATE_POINTER_ERROR_RETURN</code>的操作，就是如果源字符串NULL，直接把目的字符串重置，然后返回验证一个什么值并返回</p><pre><code class="c++">// from internal_securecrt.h#define _RESET_STRING(_String, _Size) \    *(_String) = 0; \    _FILL_STRING((_String), (_Size), 1);// from internal_securecrt.h/* string resetting */#define _FILL_STRING _SECURECRT__FILL_STRING// from internal.h#if _SECURECRT_FILL_BUFFER#define _SECURECRT__FILL_STRING(_String, _Size, _Offset)                            \    if ((_Size) != ((size_t)-1) &amp;&amp; (_Size) != INT_MAX &amp;&amp;                            \        ((size_t)(_Offset)) &lt; (_Size))                                              \    {                                                                               \        memset((_String) + (_Offset),                                               \            _SECURECRT_FILL_BUFFER_PATTERN,                                         \            (_SECURECRT_FILL_BUFFER_THRESHOLD &lt; ((size_t)((_Size) - (_Offset))) ?   \                _SECURECRT_FILL_BUFFER_THRESHOLD :                                  \                ((_Size) - (_Offset))) * sizeof(*(_String)));                       \    }#else  /* _SECURECRT_FILL_BUFFER */#define _SECURECRT__FILL_STRING(_String, _Size, _Offset)#endif  /* _SECURECRT_FILL_BUFFER */// from internal.h#ifdef _DEBUG#define _SECURECRT_FILL_BUFFER 1#else  /* _DEBUG */#define _SECURECRT_FILL_BUFFER 0#endif  /* _DEBUG */// from corecrt.h, 0xFE = 254#define _SECURECRT_FILL_BUFFER_PATTERN 0xFE// from internal.h#ifdef _DEBUG#define _SECURECRT_FILL_BUFFER_THRESHOLD __crtDebugFillThreshold#else  /* _DEBUG */#define _SECURECRT_FILL_BUFFER_THRESHOLD ((size_t)0)#endif  /* _DEBUG */// from dbgheap.cextern &quot;C&quot; size_t __crtDebugFillThreshold = SIZE_MAX;</code></pre><p>这里比较巧妙，重置字符串，一般情况下仅将_DSET首个char的值赋值 <code>*(_DEST) = 0;</code>；DEBUG模式下才<code>_FILL_STRING</code>，其中还用<code>_SECURECRT_FILL_BUFFER_THRESHOLD</code>长度判断，还是跟着DEBUG走的，用memset将后面剩下的char赋值为254。后面在<code>_FILL_STRING</code>章节详细论述一下这个</p><pre><code class="c++">// from internal_securecrt.h#define _VALIDATE_POINTER_ERROR_RETURN(_Pointer, _ErrorCode, _Ret) \    _VALIDATE_RETURN((_Pointer) != NULL, (_ErrorCode), (_Ret))</code></pre><h4 id="小结（-VALIDATE-POINTER-RESET-STRING）"><a href="#小结（-VALIDATE-POINTER-RESET-STRING）" class="headerlink" title="小结（-VALIDATE-POINTER-RESET-STRING）"></a>小结（-VALIDATE-POINTER-RESET-STRING）</h4><p>上个宏检查DEST，这个宏检查<code>_SRC != NULL</code>，不满足则将DEST首个字符的值赋0，DEBUG模式下会有一套更安全但是更耗性能的DEST重置方式，放在后面<code>_FILL_STRING</code>的时候一起写</p><pre><code class="c++">// Same like _VALIDATE_POINTER_RESET_STRING(_SRC, _DEST, _SIZE);if (_SRC == NULL) {    *_DEST = 0;#ifdef _DEBUG    _FILL_STRING(_DEST, _SIZE, 1);#endif    errno = EINVAL;    return EINVAL;}</code></pre><h3 id="RESET-STRING"><a href="#RESET-STRING" class="headerlink" title="_RESET_STRING"></a><code>_RESET_STRING</code></h3><pre><code class="c++">_RESET_STRING(_DEST, _SIZE);// from internal_securecrt.h#define _RESET_STRING(_String, _Size) \    *(_String) = 0; \    _FILL_STRING((_String), (_Size), 1);</code></pre><p>上面已经套娃过这个宏了，不再赘述</p><h4 id="小结（-RESET-STRING）"><a href="#小结（-RESET-STRING）" class="headerlink" title="小结（-RESET-STRING）"></a>小结（-RESET-STRING）</h4><p>同样_DEBUG的时候，更安全的重置方式，放在后面<code>_FILL_STRING</code>的时候一起写</p><pre><code class="c++">// Same like _RESET_STRING(_DEST, _SIZE);*_DEST = 0;#ifdef _DEBUG    _FILL_STRING(_DEST, _SIZE, 1);#endif</code></pre><h3 id="RETURN-BUFFER-TOO-SMALL"><a href="#RETURN-BUFFER-TOO-SMALL" class="headerlink" title="_RETURN_BUFFER_TOO_SMALL"></a><code>_RETURN_BUFFER_TOO_SMALL</code></h3><pre><code class="c++">_RETURN_BUFFER_TOO_SMALL(_DEST, _SIZE);// from internal_securecrt.h#define _RETURN_BUFFER_TOO_SMALL(_String, _Size) \    _RETURN_BUFFER_TOO_SMALL_ERROR((_String), (_Size), ERANGE)// from internal_securecrt.h#define _RETURN_BUFFER_TOO_SMALL_ERROR(_String, _Size, _Ret) \    _VALIDATE_RETURN((L&quot;Buffer is too small&quot; &amp;&amp; 0), ERANGE, _Ret)// from errno.h#define ERANGE          34</code></pre><h4 id="小结（-RETURN-BUFFER-TOO-SMALL）"><a href="#小结（-RETURN-BUFFER-TOO-SMALL）" class="headerlink" title="小结（-RETURN-BUFFER-TOO-SMALL）"></a>小结（-RETURN-BUFFER-TOO-SMALL）</h4><pre><code class="c++">// Same like _RETURN_BUFFER_TOO_SMALL(_DEST, _SIZE);errno = ERANGE;return ERANGE;</code></pre><h3 id="FILL-STRING"><a href="#FILL-STRING" class="headerlink" title="_FILL_STRING"></a><code>_FILL_STRING</code></h3><p>终于讲到前面反复提及的_FILL_STRING了，其实也并没有很复杂，先看下定义</p><pre><code class="c++">// from internal_securecrt.h/* string resetting */#define _FILL_STRING _SECURECRT__FILL_STRING// from internal.h#if _SECURECRT_FILL_BUFFER#define _SECURECRT__FILL_STRING(_String, _Size, _Offset)                            \    if ((_Size) != ((size_t)-1) &amp;&amp; (_Size) != INT_MAX &amp;&amp;                            \        ((size_t)(_Offset)) &lt; (_Size))                                              \    {                                                                               \        memset((_String) + (_Offset),                                               \            _SECURECRT_FILL_BUFFER_PATTERN,                                         \            (_SECURECRT_FILL_BUFFER_THRESHOLD &lt; ((size_t)((_Size) - (_Offset))) ?   \                _SECURECRT_FILL_BUFFER_THRESHOLD :                                  \                ((_Size) - (_Offset))) * sizeof(*(_String)));                       \    }#else  /* _SECURECRT_FILL_BUFFER */#define _SECURECRT__FILL_STRING(_String, _Size, _Offset)#endif  /* _SECURECRT_FILL_BUFFER */// from internal.h#ifdef _DEBUG#define _SECURECRT_FILL_BUFFER 1#else  /* _DEBUG */#define _SECURECRT_FILL_BUFFER 0#endif  /* _DEBUG */// from corecrt.h, 0xFE = 254#define _SECURECRT_FILL_BUFFER_PATTERN 0xFE// from internal.h#ifdef _DEBUG#define _SECURECRT_FILL_BUFFER_THRESHOLD __crtDebugFillThreshold#else  /* _DEBUG */#define _SECURECRT_FILL_BUFFER_THRESHOLD ((size_t)0)#endif  /* _DEBUG */// from dbgheap.cextern &quot;C&quot; size_t __crtDebugFillThreshold = SIZE_MAX;</code></pre><p><code>_FILL_STRING</code>整个宏，仅在_DEBUG定义时work，否则什么也不做；</p><p><code>_SECURECRT__FILL_STRING(_String, _Size, _Offset)</code><br>三个参数很好理解，目的字符串、目的字符串长度、填充的起始偏移量</p><p><code>if ((_Size) != ((size_t)-1) &amp;&amp; (_Size) != INT_MAX &amp;&amp; ((size_t)(_Offset)) &lt; (_Size))</code><br>就是检查_Size合法性，并且要求_Offset小于_Size</p><p>然后<code>memset</code>从<code>(_String) + (_Offset)</code>地址开始，填充<code>0xFE</code>。非DEBUG模式下填充0个字节，还是相当于什么也不做，多一重判断；DEBUG模式下填充<code>(_Size - _Offset) * sizeof(char)</code>。</p><h4 id="小结（-FILL-STRING）"><a href="#小结（-FILL-STRING）" class="headerlink" title="小结（-FILL-STRING）"></a>小结（-FILL-STRING）</h4><pre><code class="c++">// Same like _FILL_STRING(_DEST, _SIZE, _OFFSET);#ifdef _DEBUG    if (_OFFSET &lt; _Size)    {        memset(_DEST + _OFFSET, 0xFE, (_Size - _Offset) * sizeof(char));    }#else// Do nothing;#endif</code></pre><h3 id="RETURN-NO-ERROR"><a href="#RETURN-NO-ERROR" class="headerlink" title="_RETURN_NO_ERROR"></a><code>_RETURN_NO_ERROR</code></h3><pre><code class="c++">// from internal_securecrt.h/* returns without calling _invalid_parameter */#define _RETURN_NO_ERROR \    return 0</code></pre><p>终于有一个不套娃的了XD</p><h4 id="小结（-RETURN-NO-ERROR）"><a href="#小结（-RETURN-NO-ERROR）" class="headerlink" title="小结（-RETURN-NO-ERROR）"></a>小结（-RETURN-NO-ERROR）</h4><pre><code class="c++">// Same like _RETURN_NO_ERROR;return 0;</code></pre><h2 id="分析结论"><a href="#分析结论" class="headerlink" title="分析结论"></a>分析结论</h2><p>再粘一遍源码，方便对照着看</p><pre><code class="c++">_FUNC_PROLOGUEerrno_t __cdecl _FUNC_NAME(_CHAR *_DEST, size_t _SIZE, const _CHAR *_SRC){    _CHAR *p;    size_t available;    /* validation section */    _VALIDATE_STRING(_DEST, _SIZE);    _VALIDATE_POINTER_RESET_STRING(_SRC, _DEST, _SIZE);    p = _DEST;    available = _SIZE;    while ((*p++ = *_SRC++) != 0 &amp;&amp; --available &gt; 0)    {    }    if (available == 0)    {        _RESET_STRING(_DEST, _SIZE);        _RETURN_BUFFER_TOO_SMALL(_DEST, _SIZE);    }    _FILL_STRING(_DEST, _SIZE, _SIZE - available + 1);    _RETURN_NO_ERROR;}</code></pre><ol><li><code>_VALIDATE_STRING(_DEST, _SIZE);</code> 检验<code>_DEST != NULL &amp;&amp; _Size &gt; 0</code>是否满足；若为假，则<code>errno = EINVAL</code>，并直接<code>return EINVAL</code>；如果是在Debug模式下（<code>_DEBUG</code>宏被定义过）还会弹出提示窗口、触发调试断点、记录下错误发生位置等</li><li><code>_VALIDATE_POINTER_RESET_STRING(_SRC, _DEST, _SIZE);</code> 判断<code>_SRC == NULL</code>是否满足；若为真，则Reset <code>_DEST</code>，<code>errno = EINVAL</code>，并直接<code>return EINVAL</code>，Debug模式下也同样弹窗、断点、错误等</li><li>算法逻辑：与分析中的没有区别，逐字符拷贝，如果正常拷到<code>&#39;\0&#39;</code>，或者<code>available</code>跑完了，就停止</li><li>如果<code>available == 0</code>，说明<code>_SRC</code>的长度超过了<code>_SIZE</code>，即超过了目的字符串最大可用长度，拷贝失败。</li><li><code>_RESET_STRING(_DEST, _SIZE);</code> 重置字符串，<code>*_DEST = 0;</code>，且<code>_FILL_STRING(_DEST, _SIZE, 1);</code>。即将首个字符赋值为<code>&#39;\0&#39;</code>，后面的字符填充安全字符<code>0xFE</code>。需要说明的是，<code>_FILL_STRING</code>也仅在Debug模式下才进行，否则什么也不处理</li><li><code>_RETURN_BUFFER_TOO_SMALL(_DEST, _SIZE);</code> <code>errno = ERANGE</code>，并直接<code>return ERANGE</code>，Debug模式下也同样弹窗、断点、错误等</li><li><code>_FILL_STRING(_DEST, _SIZE, _SIZE - available + 1);</code>就是调用<code>memset</code>，将<code>_DEST</code>比<code>_SRC</code>多出来的部分（<code>[_SIZE - available + 1, _Size)</code>）全部填充为安全字符<code>0xFE</code>。同样，<code>_FILL_STRING</code>也仅在Debug模式下才进行，否则什么也不处理</li></ol><p>可能有点绕，接着看下一章节简化实现应该就清晰了~</p><h2 id="简化实现"><a href="#简化实现" class="headerlink" title="简化实现"></a>简化实现</h2><p>看完了源码，我们来写个简单点的strcpy_s吧</p><pre><code class="c++">void fill_string(char * string, size_t size, size_t offset);errno_t strcpy_s(char *_DEST, size_t _SIZE, const char *_SRC){    char *p;    size_t available;    if (!(_DEST != NULL &amp;&amp; _Size &gt; 0))    {        errno = EINVAL;        return EINVAL;    }    if (_SRC == NULL) {        *_DEST = 0;        fill_string(_DEST, _SIZE, 1);        errno = EINVAL;        return EINVAL;    }    p = _DEST;    available = _SIZE;    while ((*p++ = *_SRC++) != 0 &amp;&amp; --available &gt; 0)    {    }    if (available == 0)    {        *_DEST = 0;        fill_string(_DEST, _SIZE, 1);        errno = ERANGE;        return ERANGE;    }    fill_string(_DEST, _SIZE, _SIZE - available + 1);    return 0;}inline void fill_string(char * string, size_t size, size_t offset){#ifdef _DEBUG    if (offset &lt; size)    {        memset(string + offset, 0xFE, (size - offset) * sizeof(char));    }#else    // do nothing    ;#endif}</code></pre><h2 id="扩展延伸"><a href="#扩展延伸" class="headerlink" title="扩展延伸"></a>扩展延伸</h2><p>既然讲完了<code>strcpy_s</code>，那其他的字符串操作函数的<code>_safe</code>版本呢？下面再看下<code>strcat_s</code>和<code>strset_s</code>。也不多啰嗦了，直接粘出没见过的宏的实现，然后我们在写个简化实现看下~</p><h3 id="strcat-s"><a href="#strcat-s" class="headerlink" title="strcat_s"></a><code>strcat_s</code></h3><pre><code class="c++">/****tcscat_s.inl - general implementation of _tcscpy_s**       Copyright (c) Microsoft Corporation. All rights reserved.**Purpose:*       This file contains the general algorithm for strcat_s and its variants.*****/_FUNC_PROLOGUEerrno_t __cdecl _FUNC_NAME(_CHAR *_DEST, size_t _SIZE, const _CHAR *_SRC){    _CHAR *p;    size_t available;    /* validation section */    _VALIDATE_STRING(_DEST, _SIZE);    _VALIDATE_POINTER_RESET_STRING(_SRC, _DEST, _SIZE);    p = _DEST;    available = _SIZE;    while (available &gt; 0 &amp;&amp; *p != 0)    {        p++;        available--;    }    if (available == 0)    {        _RESET_STRING(_DEST, _SIZE);        _RETURN_DEST_NOT_NULL_TERMINATED(_DEST, _SIZE);    }    while ((*p++ = *_SRC++) != 0 &amp;&amp; --available &gt; 0)    {    }    if (available == 0)    {        _RESET_STRING(_DEST, _SIZE);        _RETURN_BUFFER_TOO_SMALL(_DEST, _SIZE);    }    _FILL_STRING(_DEST, _SIZE, _SIZE - available + 1);    _RETURN_NO_ERROR;}</code></pre><p>没见过的宏：</p><pre><code class="c++">// from internal_securecrt.h#define _RETURN_DEST_NOT_NULL_TERMINATED(_String, _Size) \    _VALIDATE_RETURN((L&quot;String is not null terminated&quot; &amp;&amp; 0), EINVAL, EINVAL)</code></pre><p>简化实现：</p><pre><code class="c++">void fill_string(char * string, size_t size, size_t offset);errno_t strcat_s(char *_DEST, size_t _SIZE, const char *_SRC){    char *p;    size_t available;    if (!(_DEST != NULL &amp;&amp; _Size &gt; 0))    {        errno = EINVAL;        return EINVAL;    }    if (_SRC == NULL) {        *_DEST = 0;        fill_string(_DEST, _SIZE, 1);        errno = EINVAL;        return EINVAL;    }    p = _DEST;    available = _SIZE;    while (available &gt; 0 &amp;&amp; *p != 0)    {        p++;        available--;    }    if (available == 0)    {        *_DEST = 0;        fill_string(_DEST, _SIZE, 1);        errno = EINVAL;        return EINVAL;    }    while ((*p++ = *_SRC++) != 0 &amp;&amp; --available &gt; 0)    {    }    if (available == 0)    {        *_DEST = 0;        fill_string(_DEST, _SIZE, 1);        errno = ERANGE;        return ERANGE;    }    fill_string(_DEST, _SIZE, _SIZE - available + 1);    return 0;}inline void fill_string(char * string, size_t size, size_t offset){#ifdef _DEBUG    if (offset &lt; size)    {        memset(string + offset, 0xFE, (size - offset) * sizeof(char));    }#else    // do nothing    ;#endif</code></pre><h3 id="strset-s"><a href="#strset-s" class="headerlink" title="strset_s"></a><code>strset_s</code></h3><pre><code class="c++">/****tcsset_s.inl - general implementation of _tcsset_s**       Copyright (c) Microsoft Corporation. All rights reserved.**Purpose:*       This file contains the general algorithm for _strset_s and its variants.*****/_FUNC_PROLOGUEerrno_t __cdecl _FUNC_NAME(_CHAR *_DEST, size_t _SIZE, _CHAR_INT _Value){    _CHAR *p;    size_t available;    /* validation section */    _VALIDATE_STRING(_DEST, _SIZE);    p = _DEST;    available = _SIZE;    while (*p != 0 &amp;&amp; --available &gt; 0)    {        *p++ = (_CHAR)_Value;    }    if (available == 0)    {        _RESET_STRING(_DEST, _SIZE);        _RETURN_DEST_NOT_NULL_TERMINATED(_DEST, _SIZE);    }    _FILL_STRING(_DEST, _SIZE, _SIZE - available + 1);    _RETURN_NO_ERROR;}</code></pre><p>简化实现：</p><pre><code class="c++">void fill_string(char * string, size_t size, size_t offset);errno_t strset_s(char *_DEST, size_t _SIZE, int _Value){    char *p;    size_t available;    if (!(_DEST != NULL &amp;&amp; _Size &gt; 0))    {        errno = EINVAL;        return EINVAL;    }    p = _DEST;    available = _SIZE;    while (*p != 0 &amp;&amp; --available &gt; 0)    {        *p++ = (char)_Value;    }    if (available == 0)    {        *_DEST = 0;        fill_string(_DEST, _SIZE, 1);        errno = EINVAL;        return EINVAL;    }    fill_string(_DEST, _SIZE, _SIZE - available + 1);    return 0;}inline void fill_string(char * string, size_t size, size_t offset){#ifdef _DEBUG    if (offset &lt; size)    {        memset(string + offset, 0xFE, (size - offset) * sizeof(char));    }#else    // do nothing    ;#endif}</code></pre><h2 id="进一步扩展"><a href="#进一步扩展" class="headerlink" title="进一步扩展"></a>进一步扩展</h2><p>聊完了普通版本的_Safe版本string函数，再进一步扩展下所有的string函数safe版本</p><p>肝力有限，先把微软的实现粘出来，有空再更新吧</p><h3 id="strtok-s"><a href="#strtok-s" class="headerlink" title="strtok_s"></a><code>strtok_s</code></h3><pre><code class="c++">/****tcstok_s.inl - general implementation of _tcstok_s**       Copyright (c) Microsoft Corporation. All rights reserved.**Purpose:*       This file contains the general algorithm for strtok_s and its variants.*****/_FUNC_PROLOGUE_CHAR * __cdecl _FUNC_NAME(_CHAR *_String, const _CHAR *_Control, _CHAR **_Context){    _CHAR *token;    const _CHAR *ctl;    /* validation section */    _VALIDATE_POINTER_ERROR_RETURN(_Context, EINVAL, NULL);    _VALIDATE_POINTER_ERROR_RETURN(_Control, EINVAL, NULL);    _VALIDATE_CONDITION_ERROR_RETURN(_String != NULL || *_Context != NULL, EINVAL, NULL);    /* If string==NULL, continue with previous string */    if (!_String)    {        _String = *_Context;    }    /* Find beginning of token (skip over leading delimiters). Note that    * there is no token iff this loop sets string to point to the terminal null. */    for ( ; *_String != 0 ; _String++)    {        for (ctl = _Control; *ctl != 0 &amp;&amp; *ctl != *_String; ctl++)            ;        if (*ctl == 0)        {            break;        }    }    token = _String;    /* Find the end of the token. If it is not the end of the string,    * put a null there. */    for ( ; *_String != 0 ; _String++)    {        for (ctl = _Control; *ctl != 0 &amp;&amp; *ctl != *_String; ctl++)            ;        if (*ctl != 0)        {            *_String++ = 0;            break;        }    }    /* Update the context */    *_Context = _String;    /* Determine if a token has been found. */    if (token == _String)    {        return NULL;    }    else    {        return token;    }}</code></pre><h3 id="strncpy-s"><a href="#strncpy-s" class="headerlink" title="strncpy_s"></a><code>strncpy_s</code></h3><pre><code class="c++">/****tcsncpy_s.inl - general implementation of _tcsncpy_s**       Copyright (c) Microsoft Corporation. All rights reserved.**Purpose:*       This file contains the general algorithm for strncpy_s and its variants.*****/_FUNC_PROLOGUEerrno_t __cdecl _FUNC_NAME(_CHAR *_DEST, size_t _SIZE, const _CHAR *_SRC, size_t _COUNT){    _CHAR *p;    size_t available;    if (_COUNT == 0 &amp;&amp; _DEST == NULL &amp;&amp; _SIZE == 0)    {        /* this case is allowed; nothing to do */        _RETURN_NO_ERROR;    }    /* validation section */    _VALIDATE_STRING(_DEST, _SIZE);    if (_COUNT == 0)    {        /* notice that the source string pointer can be NULL in this case */        _RESET_STRING(_DEST, _SIZE);        _RETURN_NO_ERROR;    }    _VALIDATE_POINTER_RESET_STRING(_SRC, _DEST, _SIZE);    p = _DEST;    available = _SIZE;    if (_COUNT == _TRUNCATE)    {        while ((*p++ = *_SRC++) != 0 &amp;&amp; --available &gt; 0)        {        }    }    else    {        _ASSERT_EXPR((!_CrtGetCheckCount() || _COUNT &lt; _SIZE), L&quot;Buffer is too small&quot;);        while ((*p++ = *_SRC++) != 0 &amp;&amp; --available &gt; 0 &amp;&amp; --_COUNT &gt; 0)        {        }        if (_COUNT == 0)        {            *p = 0;        }    }    if (available == 0)    {        if (_COUNT == _TRUNCATE)        {            _DEST[_SIZE - 1] = 0;            _RETURN_TRUNCATE;        }        _RESET_STRING(_DEST, _SIZE);        _RETURN_BUFFER_TOO_SMALL(_DEST, _SIZE);    }    _FILL_STRING(_DEST, _SIZE, _SIZE - available + 1);    _RETURN_NO_ERROR;}</code></pre><h3 id="strncat-s"><a href="#strncat-s" class="headerlink" title="strncat_s"></a><code>strncat_s</code></h3><pre><code class="c++">/****tcsncat_s.inl - general implementation of _tcscpy_s**       Copyright (c) Microsoft Corporation. All rights reserved.**Purpose:*       This file contains the general algorithm for strncat_s and its variants.*****/_FUNC_PROLOGUEerrno_t __cdecl _FUNC_NAME(_CHAR *_DEST, size_t _SIZE, const _CHAR *_SRC, size_t _COUNT){    _CHAR *p;    size_t available;    if (_COUNT == 0 &amp;&amp; _DEST == NULL &amp;&amp; _SIZE == 0)    {        /* this case is allowed; nothing to do */        _RETURN_NO_ERROR;    }    /* validation section */    _VALIDATE_STRING(_DEST, _SIZE);    if (_COUNT != 0)    {        _VALIDATE_POINTER_RESET_STRING(_SRC, _DEST, _SIZE);    }    p = _DEST;    available = _SIZE;    while (available &gt; 0 &amp;&amp; *p != 0)    {        p++;        available--;    }    if (available == 0)    {        _RESET_STRING(_DEST, _SIZE);        _RETURN_DEST_NOT_NULL_TERMINATED(_DEST, _SIZE);    }    if (_COUNT == _TRUNCATE)    {        while ((*p++ = *_SRC++) != 0 &amp;&amp; --available &gt; 0)        {        }    }    else    {        _ASSERT_EXPR((!_CrtGetCheckCount() || _COUNT &lt; available), L&quot;Buffer is too small&quot;);        while (_COUNT &gt; 0 &amp;&amp; (*p++ = *_SRC++) != 0 &amp;&amp; --available &gt; 0)        {            _COUNT--;        }        if (_COUNT == 0)        {            *p = 0;        }    }    if (available == 0)    {        if (_COUNT == _TRUNCATE)        {            _DEST[_SIZE - 1] = 0;            _RETURN_TRUNCATE;        }        _RESET_STRING(_DEST, _SIZE);        _RETURN_BUFFER_TOO_SMALL(_DEST, _SIZE);    }    _FILL_STRING(_DEST, _SIZE, _SIZE - available + 1);    _RETURN_NO_ERROR;}</code></pre><h3 id="strnset-s"><a href="#strnset-s" class="headerlink" title="strnset_s"></a><code>strnset_s</code></h3><pre><code class="c++">/****tcsnset_s.inl - general implementation of _tcsnset_s**       Copyright (c) Microsoft Corporation. All rights reserved.**Purpose:*       This file contains the general algorithm for _strnset_s and its variants.*****/_FUNC_PROLOGUEerrno_t __cdecl _FUNC_NAME(_CHAR *_DEST, size_t _SIZE, _CHAR_INT _Value, size_t _COUNT){    _CHAR *p;    size_t available;    /* validation section */    if (_COUNT == 0 &amp;&amp; _DEST == NULL &amp;&amp; _SIZE == 0)    {        /* this case is allowed; nothing to do */        _RETURN_NO_ERROR;    }    _VALIDATE_STRING(_DEST, _SIZE);    _ASSERT_EXPR((!_CrtGetCheckCount() || _COUNT &lt; _SIZE), L&quot;Buffer is too small&quot;);    p = _DEST;    available = _SIZE;    while (*p != 0 &amp;&amp; _COUNT &gt; 0 &amp;&amp; --available &gt; 0)    {        *p++ = (_CHAR)_Value;        --_COUNT;    }    if (_COUNT == 0)    {        /* ensure the string is null-terminated */        while (*p != 0 &amp;&amp; --available &gt; 0)        {            ++p;        }    }    if (available == 0)    {        _RESET_STRING(_DEST, _SIZE);        _RETURN_DEST_NOT_NULL_TERMINATED(_DEST, _SIZE);    }    _FILL_STRING(_DEST, _SIZE, _SIZE - available + 1);    _RETURN_NO_ERROR;}</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/djzny/p/4476221.html" target="_blank" rel="noopener">C++string函数之strcpy_s</a> 注：该文章中对几个宏的解释存在错误，请甄别阅读</li><li><a href="https://bbs.csdn.net/topics/390641877" target="_blank" rel="noopener">strcpy_s的函数实现是啥？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在C标准库中提供了字符串拷贝函数&lt;code&gt;strcpy&lt;/code&gt;，而微软则为为它提供了一个更安全的版本&lt;code&gt;strcpy_s&lt;/code&gt;，其函数原型为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c++&quot;&gt;errno_t __cdecl strcpy_s(
    char*       _Destination,
    rsize_t     _SizeInBytes,
    char const* _Source
    );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分享下它的实现和一些个人理解&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://www.misteo.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="C/C++" scheme="http://www.misteo.top/tags/C-C/"/>
    
      <category term="STL" scheme="http://www.misteo.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>散点波形图求峰值面积比</title>
    <link href="http://www.misteo.top/2018/08/13/%E6%95%A3%E7%82%B9%E6%B3%A2%E5%BD%A2%E5%9B%BE%E6%B1%82%E5%B3%B0%E5%80%BC%E9%9D%A2%E7%A7%AF/"/>
    <id>http://www.misteo.top/2018/08/13/散点波形图求峰值面积/</id>
    <published>2018-08-13T09:17:05.000Z</published>
    <updated>2020-11-30T13:16:04.438Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间接到了个需求，数据是几千个散点，绘制出来波形图，有多个波峰，需求是求出各个波峰与第一个波峰的面积比值。乍一看需求有点难以实现，其实细化成各个模块之后也算比较简单，在这里总结一下经验方法</p><a id="more"></a><p><img src="/post_images/crest_1.png" alt="数据绘制"></p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>首先分清要做什么，既然是散点，那肯定需要平滑。得出了平滑曲线之后，怎么求波峰？当然是取极大值，就是散点求导，求完导可能需要对导函数散点再次平滑。求面积就积分，至于积分取值区间，就是前一个极小值到后一个极小值的差。（我们的需求比较特殊，要取值区间固定大小，所以在这里略有不同），总结一下：</p><ol><li>散点平滑</li><li>求散点导</li><li>散点导平滑</li><li>求极值</li><li>积分求面积</li></ol><p>下面逐条分析</p><h2 id="散点平滑"><a href="#散点平滑" class="headerlink" title="散点平滑"></a>散点平滑</h2><p>平滑就比较简单了，这里用了<code>均值滤波</code>，说白了就是前后求均值。</p><p>直接上代码吧，原理简单效果显著</p><pre><code class="c++">std::vector&lt;double&gt; blur(const std::vector&lt;double&gt;&amp; data, int kernel_size, double center_value){    std::vector&lt;double&gt; dst;    for (int i = 0; i != data.size(); ++i) {        // 均值滤波        double sum = data.at(i) * center_value;        double count = center_value;        for (int j = 1; j != kernel_size; ++j) {            if (i - j &gt;= 0) {                sum += data.at(i - j);                ++count;            }            if (i + j &lt; data.size()) {                sum += data.at(i + j);                ++count;            }        }        dst.push_back(sum / count);    }    return dst;}</code></pre><p><img src="/post_images/crest_2.png" alt="平滑曲线"></p><p>当然也可以尝试更高级的高斯滤波或者其他方法，有兴趣可以再研究一下。</p><h2 id="求散点导"><a href="#求散点导" class="headerlink" title="求散点导"></a>求散点导</h2><p>曲线拟合比较复杂，主要波形也不固定需要分段拟合，运行环境也不一定能上ml，所有还是手工用算法操作，这里使用的是<code>中间差分法</code>，具体的数学原理就不是我们研究的范围了，<a href="http://379910987.blog.163.com/blog/static/33523797201293125832513/" target="_blank" rel="noopener">公式</a>可以参考一下</p><pre><code class="c++">std::vector&lt;double&gt; derivative(const std::vector&lt;double&gt;&amp; data, const int h_value){    std::vector&lt;double&gt; dst;    for (int x = 2 * h_value; x != data.size() - (2 * h_value); ++x) {        double fx = (-data.at(x + 2 * h_value) + 8 * data.at(x + h_value) - 8 * data.at(x - h_value) + data.at(x - 2 * h_value)) / (12 * h_value);        dst.push_back(fx);    }    return dst;}</code></pre><p>这里没有对前后<code>2*h_value</code>进行计算，可以使用<code>向前差分</code>和<code>向后差分</code>进行完整的散点导数计算，由于我们的项目不需要，所以不做赘述</p><p><em>上面是重新调整参数后的平滑曲线，下面是已经平滑过的导函数曲线</em><br><img src="/post_images/crest_3.png" alt="导函数曲线"></p><h2 id="散点导平滑"><a href="#散点导平滑" class="headerlink" title="散点导平滑"></a>散点导平滑</h2><p>没什么好说的，将导数的数据再次进行平滑即可</p><h2 id="求极值"><a href="#求极值" class="headerlink" title="求极值"></a>求极值</h2><p>由于我们求出来的是散点导数，而不是导数方程，所以直接通过<code>f&#39;(x) == 0</code>判断并不合适（因为散点并不一定落在x轴上），但是导数点一定是两边异号，这样也就很好判断了，通过<code>f&#39;(x-x0) * f&#39;(x) &lt;= 0</code>即可。</p><pre><code class="c++">std::vector&lt;double&gt; extremum(const std::vector&lt;double&gt;&amp; data, int flag = 0){    std::vector&lt;double&gt; dst;    for (int i = 1; i != data.size(); ++i) {        // 左右异号，则为极值        if (data.at(i - 1) * data.at(i) &lt;= 0) {            if (flag &gt; 0) {                if (data.at(i - 1) &lt; 0 || data.at(i) &gt; 0) {                    continue;                }            } else if (flag &lt; 0) {                if (data.at(i - 1) &gt; 0 || data.at(i) &lt; 0) {                    continue;                }            }            else {  // flag == 0                ;            }            // 取离0近的那个            if (std::abs(data.at(i - 1)) &lt; std::abs(data.at(i))) {                dst.push_back(i - 1);            } else {                dst.push_back(i);            }        }    }    return dst;}</code></pre><p>代码中的<code>flag</code>参数用于仅取极大值或极小值。</p><h2 id="积分求面积"><a href="#积分求面积" class="headerlink" title="积分求面积"></a>积分求面积</h2><p><code>Σf(x-x0)</code>，x0即为要选择的底部，积分范围从上一个极小值到下一个极小值即可。</p><p>我们的需求比较特殊，需要取值区间宽度固定，由于以第一个波峰作为基准，所以取其上一个极小值到下一个极小值的宽度的比值（实际取了三分之一）</p><pre><code class="c++">double crest_area(const std::vector&lt;double&gt;&amp; data, const std::vector&lt;double&gt;&amp; extrem, int crest_index, int width_ratio = 3){    int width = (extrem.at(1) - extrem.at(0)) / width_ratio;    double bottom = data.at(extrem.at(1));    // 积分求面积    double area = 0;    for (int i = -width; i != width; ++i) {        area += data.at(extrem.at(i * 2)) - bottom;    }    return area;}</code></pre><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>依次调各个函数吧</p><pre><code class="c++">struct CrestRatioArg;std::vector&lt;double&gt; calc_crest_ratio(const std::vector&lt;double&gt;&amp; data, const CrestRatioArg &amp; arg){    auto blur_dst = blur(data, arg.kernel_size1, arg.center_value1);    auto dv_dst = derivative(blur_dst, arg.dv_h_value);    auto dv_blur_dst = blur(dv_dst, arg.kernel_size2, arg.center_value2);    auto full_extrem_dst = extremum(dv_blur_dst);    std::vector&lt;double&gt; result;    if (full_extrem_dst.empty()) {        return result;    }    double first_crest_area = crest_area(blur_dst, full_extrem_dst, 0, arg.integral_width_ratio);    if (first_crest_area == 0) {        return result;    }    for (int i = 1; i != full_extrem_dst.size() / 2 + 1; ++i) {        double current_area = crest_area(blur_dst, full_extrem_dst, i, arg.integral_width_ratio);        result.push_back(current_area / first_crest_area);    }    return result;}struct CrestRatioArg {    int kernel_size1 = 100;    int center_value1 = 1;    int dv_h_value = 100;    int kernel_size2 = 20;    int center_value2 = 1;    int integral_width_ratio = 3;};</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间接到了个需求，数据是几千个散点，绘制出来波形图，有多个波峰，需求是求出各个波峰与第一个波峰的面积比值。乍一看需求有点难以实现，其实细化成各个模块之后也算比较简单，在这里总结一下经验方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://www.misteo.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="C/C++" scheme="http://www.misteo.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>QML中ListView访问子组件</title>
    <link href="http://www.misteo.top/2018/06/12/QML%E4%B8%ADListView%E8%AE%BF%E9%97%AE%E5%AD%90%E7%BB%84%E4%BB%B6/"/>
    <id>http://www.misteo.top/2018/06/12/QML中ListView访问子组件/</id>
    <published>2018-06-12T09:56:59.000Z</published>
    <updated>2020-11-30T13:16:04.431Z</updated>
    
    <content type="html"><![CDATA[<p>老规矩先上结论，通过<code>contentItem.children</code>访问即可</p><pre><code class="js">var obj = listview.contentItem.children[index]</code></pre><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写QML项目难免经常要用到<a href="https://doc-snapshots.qt.io/qt5-5.9/qml-qtquick-listview.html" target="_blank" rel="noopener"><code>ListView</code></a>，可是<code>ListView</code>却不像<code>Repeater</code>一样拥有<code>itemAt(index)</code>这样的方法，只有<code>itemAt(real x, real y)</code>，需要通过坐标值来得到子组件，而作为可以滑动的列表，坐标还得实时计算，这也太蠢了，我明明只是想遍历所有子组件而已！查了很多资料终于找到了答案，使用其基类<code>QQuickItem</code>里的方法即可，而不是<code>ListView</code>里面的，即上文摘要中提到的<code>contentItem</code></p><pre><code class="js">var obj = listview.contentItem.children[index]</code></pre><h2 id="举个简单的例子"><a href="#举个简单的例子" class="headerlink" title="举个简单的例子"></a>举个简单的例子</h2><pre><code class="js">ListView {    id: listview    model: 10    delegate: TextField {        function getText() {            return text;        }    }    function getAllText() {        var allText = [];        var children = listview.contentItem.children;        for (var i = 0; i != children.length; ++i) {            allText.push(children[i].getText());        }        return allText;    }}</code></pre><h2 id="要注意的一些问题"><a href="#要注意的一些问题" class="headerlink" title="要注意的一些问题"></a>要注意的一些问题</h2><h3 id="spacing带来的问题"><a href="#spacing带来的问题" class="headerlink" title="spacing带来的问题"></a>spacing带来的问题</h3><p>不知道<code>spacing</code>具体的实现是什么，类似于给列表加上一些有长宽的<code>Item</code>或者什么的，这都不是重点，重点是加上的这些<code>Item</code>之后循环访问会出现问题，所以需要判断一下，举个例子：</p><pre><code class="js">var children = listview.contentItem.children;for (var i = 0; i !== children.length; ++i) {    if (typeof children[i].getText !== &quot;function&quot;) {    // 或者 === &quot;undefined&quot;        continue;    }    allText.push(children[i].getText());}</code></pre><p>当然也可能有更好的方法，想到再补充吧</p><h2 id="利用model的方法"><a href="#利用model的方法" class="headerlink" title="利用model的方法"></a>利用model的方法</h2><h3 id="2018-07-07更新"><a href="#2018-07-07更新" class="headerlink" title="2018-07-07更新"></a>2018-07-07更新</h3><p>临时想到的方法，还没有进一步验证，可能需要加一些处理才能使用，仅供参考</p><pre><code class="js">for (var i in listview.model) {    allText.push(i[&quot;xxx&quot;]);}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;老规矩先上结论，通过&lt;code&gt;contentItem.children&lt;/code&gt;访问即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;var obj = listview.contentItem.children[index]
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="QML" scheme="http://www.misteo.top/tags/QML/"/>
    
  </entry>
  
  <entry>
    <title>HC5761刷OpenWrt并配置多播小结</title>
    <link href="http://www.misteo.top/2018/04/04/%E6%9E%81%E8%B4%B0%E5%88%B7OpenWrt%E5%B9%B6%E9%85%8D%E7%BD%AE%E5%A4%9A%E6%92%AD%E5%B0%8F%E7%BB%93/"/>
    <id>http://www.misteo.top/2018/04/04/极贰刷OpenWrt并配置多播小结/</id>
    <published>2018-04-04T02:55:17.000Z</published>
    <updated>2020-11-30T13:16:04.439Z</updated>
    
    <content type="html"><![CDATA[<p>这几天把公司宿舍的网络好好的折腾了一下，从平均10Mbps最高20Mbps勉强提升到了稳定30Mbps，总结一下心得</p><a id="more"></a><h2 id="获取Root"><a href="#获取Root" class="headerlink" title="获取Root"></a>获取Root</h2><p>云插件中安装<code>开发中模式</code>，好像还要关联微信什么的，GUI操作应该不困难，感觉没啥好说的，<del>其实是因为好久以前弄的具体的我不记得了</del></p><h2 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h2><p>注意以下命令行都是基于极贰（<code>HC5761</code>)，其他路由器同理，但需要改一下链接下载符合自己机型的文件不要直接复制</p><h3 id="连上极路由"><a href="#连上极路由" class="headerlink" title="连上极路由"></a>连上极路由</h3><pre><code class="bash">ssh -p 1022 root@192.168.1.1</code></pre><p>密码就是路由器的管理密码</p><h3 id="刷入Bootloader"><a href="#刷入Bootloader" class="headerlink" title="刷入Bootloader"></a>刷入Bootloader</h3><p>这里我们刷入<code>Breed</code>，一个很强大的Bootloader，想刷入其他的可以下载<a href="#相关链接">相关链接</a>中的其他文件</p><pre><code class="bash">cd /tmpwget https://breed.hackpascal.net/breed-mt7620-hiwifi-hc5761.binmtd write breed-mt7620-hiwifi-hc5761.bin u-boot</code></pre><h3 id="刷入固件"><a href="#刷入固件" class="headerlink" title="刷入固件"></a>刷入固件</h3><p>这里我们刷入<code>OpenWrt</code>，想刷入其他的可以下载<a href="#相关链接">相关链接</a>中的其他文件</p><pre><code class="bash">wget http://rssn.cn/roms/openwrt-ramips-mt7620a-hc5761-squashfs-sysupgrade.binsysupgrade -F -n openwrt-ramips-mt7620a-hc5761-squashfs-sysupgrade.bin</code></pre><p>好像是只有<code>sysupgrade.bin</code>的固件可以使用这个命令行刷入，其他的固件可以进入<code>Bootloader</code>刷，具体的步骤为</p><ol><li>断电关机</li><li>长按reset不放，同时通电，约5秒后松手</li><li>进入<a href="http://192.168.1.1" target="_blank" rel="noopener">http://192.168.1.1</a></li><li>选择<code>固件更新</code>-<code>固件</code>-上传固件并更新</li></ol><p>等待完成后重启，固件就刷好了</p><h3 id="多播设置"><a href="#多播设置" class="headerlink" title="多播设置"></a>多播设置</h3><p>待续。。。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><h3 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h3><ul><li><a href="https://breed.hackpascal.net/" target="_blank" rel="noopener">breed</a></li><li><a href="http://rssn.cn/roms/uboot/" target="_blank" rel="noopener">u-boot</a></li></ul><h3 id="Rom"><a href="#Rom" class="headerlink" title="Rom"></a>Rom</h3><ul><li><a href="http://rssn.cn/roms/" target="_blank" rel="noopener">OpenWrt</a></li><li><a href="http://opt.cn2qq.com/padavan/" target="_blank" rel="noopener">Padavan</a></li><li><a href="http://downloads.openwrt.org.cn/PandoraBox/" target="_blank" rel="noopener">PandoraBox</a></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/196a43b79c24" target="_blank" rel="noopener">极路由1、1s等机型刷OpenWrt–成为真正的极客- 简书</a></li><li><a href="http://www.right.com.cn/forum/thread-161906-1-1.html" target="_blank" rel="noopener">AR/QCA/MTK Breed，功能强大的多线程 Bootloader ,恩山无线论坛</a></li><li><a href="http://www.right.com.cn/forum/thread-161324-1-1.html" target="_blank" rel="noopener">改华硕[N14U N54U]5G 2G的7620老毛子Padavan固件(私人云储存 aria2 QOS) ,恩山无线论坛</a></li><li><a href="https://blog.csdn.net/lvshaorong/article/details/70568791" target="_blank" rel="noopener">OpenWrt路由器macvlan单线多拨的方法 - CSDN博客</a></li><li><a href="https://blog.csdn.net/lvshaorong/article/details/61916525" target="_blank" rel="noopener">OpwnWrt 路由器MWAN3多线多拨实现方法 - CSDN博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天把公司宿舍的网络好好的折腾了一下，从平均10Mbps最高20Mbps勉强提升到了稳定30Mbps，总结一下心得&lt;/p&gt;
    
    </summary>
    
    
      <category term="路由器" scheme="http://www.misteo.top/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
      <category term="教程" scheme="http://www.misteo.top/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>记一次Ubuntu下失败的显卡驱动安装</title>
    <link href="http://www.misteo.top/2018/03/18/%E8%AE%B0Ubuntu%E4%B8%8B%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85/"/>
    <id>http://www.misteo.top/2018/03/18/记Ubuntu下一次失败的显卡驱动安装/</id>
    <published>2018-03-18T15:57:12.000Z</published>
    <updated>2020-11-30T13:16:04.440Z</updated>
    
    <content type="html"><![CDATA[<p>先上结论：<strong>Ubuntu 16.04 x64下，目前没有i3-8100的核显UHD630的驱动</strong>，所以别想了，加张独显吧！</p><a id="more"></a><p>从头说起，今天把办公室电脑的CPU和主板换了，从i3-7100升级到了i3-8100，想着Linux的驱动是一起上，应该是换完插上硬盘就能用的，结果正常开始，但是分辨率始终不对。只有1024*768一个选项，办公室的电脑有两个屏幕，也一直只能镜像显示不能分屏。</p><p>这还不简单改个分辨率不就得了，直接xrandr命令修改分辨率，却提示<code>failed to get size of gamma for output default</code>，查了很多教程，依旧无解。</p><p>点击上方状态栏上<code>关于计算机</code>，图形处理器没能正确识别（具体是什么不记得了，反正不是UHD630），遂想到驱动没有正确安装。Intel的核显也不是私有驱动，在<code>设置</code>-<code>软件和更新</code>-<code>附加驱动</code>中找不到可用驱动，按照网上教程安装了<code>intel graphics update tool</code>，<em>题外话，这货真是有毒，下载驱动奇慢无比，哪怕挂代理也经常下到一半断掉</em>，多次尝试最后提示成功，但设置仍没有中分辨率的选项，xrandr依旧报错。然后又反复卸载重装，装新版本（测试过最新版为2.0.3），反复重启等等，无果。</p><p>折腾了一晚上，万般无奈只能准备重装系统了，烧好了ubuntu的镜像，启动的时候图像想到了什么，点了<code>try ubuntu without installing</code>，果然进去分辨率也不对，只有1024*768。找同事电脑试了一下，<code>try ubuntu without installing</code>进去分辨率是正确的，ohshit还是驱动问题啊，压根就没有可以用的驱动。翻出了压箱底的一张GTS450，插上主板接上供电开机。分辨率一切正常，原先i3-7100的UHD630存在的次屏幕不能自动适配分辨率需要手动xrandr的问题也解决了。。虽说换个辣鸡独显性能可能要降一大半，不过毕竟不跑GPU运算，也不用这台电脑玩游戏，无所谓啦=。=</p><p>说到底还是Intel对Linux的支持不够友好，浪费了一晚上时间就很气吧- -</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先上结论：&lt;strong&gt;Ubuntu 16.04 x64下，目前没有i3-8100的核显UHD630的驱动&lt;/strong&gt;，所以别想了，加张独显吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="吐槽" scheme="http://www.misteo.top/tags/%E5%90%90%E6%A7%BD/"/>
    
      <category term="Linux" scheme="http://www.misteo.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下源码编译安装最新版Shadowsocks-Qt5</title>
    <link href="http://www.misteo.top/2018/03/08/Ubuntu%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Shadowsocks-Qt5/"/>
    <id>http://www.misteo.top/2018/03/08/Ubuntu下编译安装最新版Shadowsocks-Qt5/</id>
    <published>2018-03-08T03:17:35.000Z</published>
    <updated>2020-11-30T13:16:04.432Z</updated>
    
    <content type="html"><![CDATA[<p>既然说好的打造技术博客，总得写点干货什么的，正好前些日子买个了新的ss服务，买完才注意到加密方式是<code>chacha20-ietf-poly1305</code>，再一看Shadowsocks-Qt5在Ubuntu的软件源里面最新版本只是2.9，不支持啊，于是只能自己研究一下怎么弄了，遇到了不少坑，和大家分享一下经验方法。</p><a id="more"></a><h2 id="卸载旧版本Shadowsocks-Qt5"><a href="#卸载旧版本Shadowsocks-Qt5" class="headerlink" title="卸载旧版本Shadowsocks-Qt5"></a>卸载旧版本<code>Shadowsocks-Qt5</code></h2><pre><code class="bash">sudo apt-get purge shadowsocks-qt5</code></pre><h2 id="安装libsodium"><a href="#安装libsodium" class="headerlink" title="安装libsodium"></a>安装<code>libsodium</code></h2><pre><code class="bash">sudo apt-get install libsodium-dev</code></pre><h2 id="安装libbotan-2-x"><a href="#安装libbotan-2-x" class="headerlink" title="安装libbotan-2.x"></a>安装<code>libbotan-2.x</code></h2><p>下载解压编译安装，没啥好说的，可以访问<a href="https://botan.randombit.net/releases/" target="_blank" rel="noopener">Botan-Index of release</a> 获取最新本版，虽说新版本好像也没啥用XD</p><pre><code class="bash">wget https://botan.randombit.net/releases/Botan-2.3.0.tgztar xvf Botan-2.3.0.tgzcd Botan-2.3.0./configure.pymakesudo make installsudo ldconfig</code></pre><h2 id="安装libQtShadowsocks"><a href="#安装libQtShadowsocks" class="headerlink" title="安装libQtShadowsocks"></a>安装<code>libQtShadowsocks</code></h2><pre><code class="bash">sudo apt-get install qt5-qmake qtbase5-dev libqrencode-dev libqtshadowsocks-dev libappindicator-dev libzbar-dev libbotan1.10-devgit clone https://github.com/shadowsocks/libQtShadowsocks.gitmkdir buildcd buildcmake ..makesudo make installsudo ldconfig</code></pre><p>如果软件源中没有libqtshadowsocks-dev，可以使用pip安装</p><pre><code class="bash">sudo apt-get install python-pipsudo pip install shadowsocks</code></pre><p>如果原先安装过Qt，可能会提示找不到Qt目录，导入环境变量，然后重新编译安装</p><pre><code class="bash">export LD_LIBRARY_PATH=/opt/Qt5.10.0/5.10.0/gcc_64/lib/rm -rf *    #删除build文件夹中文件cmake ..makesudo make installsudo ldconfig</code></pre><h2 id="安装Shadowsocks-Qt5"><a href="#安装Shadowsocks-Qt5" class="headerlink" title="安装Shadowsocks-Qt5"></a>安装<code>Shadowsocks-Qt5</code></h2><pre><code class="bash">sudo apt-get install qt5-qmake qtbase5-dev libqrencode-dev libqtshadowsocks-dev libappindicator-dev libzbar-dev libbotan1.10-devgit clone https://github.com/shadowsocks/shadowsocks-qt5.gitcd shadowsocks-qt5mkdir buildcd buildcmake ..makesudo make installsudo ldconfig</code></pre><p>如果提示找不到Qt目录，编辑<code>CMakeLists.txt</code>，加入一行并保存</p><pre><code class="cmake">set(CMAKE_PREFIX_PATH &quot;/opt/Qt5.10.0/5.10.0/gcc_64&quot;)</code></pre><p>然后重新编译安装</p><pre><code class="bash">rm -rf *    #删除build文件夹中文件cmake ..makesudo make installsudo ldconfig</code></pre><h2 id="启动ss-qt5"><a href="#启动ss-qt5" class="headerlink" title="启动ss-qt5"></a>启动<code>ss-qt5</code></h2><p>直接启动即可</p><pre><code class="bash">ss-qt5</code></pre><p>若提示</p><pre><code class="bash">ss-qt5: /usr/lib/x86_64-linux-gnu/libQt5DBus.so.5: version `Qt_5&#39; not found (required by ss-qt5)ss-qt5: /usr/lib/x86_64-linux-gnu/libQt5Network.so.5: version `Qt_5&#39; not found (required by ss-qt5)ss-qt5: /usr/lib/x86_64-linux-gnu/libQt5Gui.so.5: version `Qt_5&#39; not found (required by ss-qt5)ss-qt5: /usr/lib/x86_64-linux-gnu/libQt5Core.so.5: version `Qt_5.10&#39; not found (required by ss-qt5)ss-qt5: /usr/lib/x86_64-linux-gnu/libQt5Core.so.5: version `Qt_5&#39; not found (required by ss-qt5)ss-qt5: /usr/lib/x86_64-linux-gnu/libQt5Widgets.so.5: version `Qt_5&#39; not found (required by ss-qt5)</code></pre><p>则还是环境变量的问题，导入后重新启动即可</p><pre><code class="bash">export LD_LIBRARY_PATH=/opt/Qt5.10.0/5.10.0/gcc_64/libss-qt5</code></pre><p>启动后在<code>帮助</code>-<code>关于</code>查看一下版本号若是新版就ok了<br><img src="/post_images/ss-qt5.png" alt="ss-qt5"></p><p>这时手动添加一个新连接，就已经可以看到加密方式中有<code>chacha20-ietf-poly1305</code>选项了<br><img src="/post_images/ss-connect.png" alt="配置新连接"></p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>可以写个sh，放到桌面双击启动</p><pre><code class="bash">#/bin/bashexport LD_LIBRARY_PATH=/opt/Qt5.10.0/5.10.0/gcc_64/libss-qt5</code></pre><p>将<code>文件管理器</code>-<code>编辑</code>-<code>首选项</code>-<code>行为</code>-<code>可执行文本文件</code>修改为<code>打开可执行文本文件时运行它们</code>即可，别忘了给sh脚本执行权限哦<br><img src="/post_images/file-settings.png" alt="文件行为设置"></p><p>顺便说一下命令行中如何使用ss，以及<code>method chacha20-ietf-poly1305 not supported</code>咋解决</p><p>新建json文件，内容格式如下</p><pre><code class="json">{    &quot;server&quot;: &quot;1.2.3.4&quot;,    &quot;server_port&quot;: &quot;1234&quot;,    &quot;password&quot;: &quot;1234567&quot;,    &quot;local_address&quot;: &quot;127.0.0.1&quot;,    &quot;local_port&quot;: 1080,    &quot;timeout&quot;:300,    &quot;method&quot;:&quot;chacha20-ietf-poly1305&quot;,    &quot;fast_open&quot;: false,    &quot;workers&quot;: 1}</code></pre><p>然后安装最新版本ss并从文件中配置启动即可</p><pre><code class="bash">sudo pip install https://github.com/shadowsocks/shadowsocks/archive/master.zip -Usslocal -c xxx.json</code></pre><p>想让命令走ss推荐使用<code>porxychains</code>，具体使用方法可以Google一下不再赘述</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/shadowsocks/shadowsocks-qt5/issues/595#issue" target="_blank" rel="noopener">Add support for chacha20-ietf-poly1305 #595</a></li><li><a href="http://www.lujza.me/kali-linux-%E4%B8%8B%E5%AE%89%E8%A3%85-shadowsocks-qt5-%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">Kali Linux 下安装 Shadowsocks-qt5 及使用教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;既然说好的打造技术博客，总得写点干货什么的，正好前些日子买个了新的ss服务，买完才注意到加密方式是&lt;code&gt;chacha20-ietf-poly1305&lt;/code&gt;，再一看Shadowsocks-Qt5在Ubuntu的软件源里面最新版本只是2.9，不支持啊，于是只能自己研究一下怎么弄了，遇到了不少坑，和大家分享一下经验方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="教程" scheme="http://www.misteo.top/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Linux" scheme="http://www.misteo.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="http://www.misteo.top/2018/03/07/Hello-World/"/>
    <id>http://www.misteo.top/2018/03/07/Hello-World/</id>
    <published>2018-03-07T09:23:47.000Z</published>
    <updated>2020-11-30T13:16:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>emmm，这大概就是第一篇博文了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;emmm，这大概就是第一篇博文了&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="吐槽" scheme="http://www.misteo.top/tags/%E5%90%90%E6%A7%BD/"/>
    
  </entry>
  
</feed>
