<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>散点波形图求峰值面积比</title>
      <link href="/2018/08/13/%E6%95%A3%E7%82%B9%E6%B3%A2%E5%BD%A2%E5%9B%BE%E6%B1%82%E5%B3%B0%E5%80%BC%E9%9D%A2%E7%A7%AF/"/>
      <content type="html"><![CDATA[<p>前段时间接到了个需求，数据是几千个散点，绘制出来波形图，有多个波峰，需求是求出各个波峰与第一个波峰的面积比值。乍一看需求有点难以实现，其实细化成各个模块之后也算比较简单，在这里总结一下经验方法</p><a id="more"></a><p><img src="/post_images/crest_1.png" alt="数据绘制"></p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>首先分清要做什么，既然是散点，那肯定需要平滑。得出了平滑曲线之后，怎么求波峰？当然是取极大值，就是散点求导，求完导可能需要对导函数散点再次平滑。求面积就积分，至于积分取值区间，就是前一个极小值到后一个极小值的差。（我们的需求比较特殊，要取值区间固定大小，所以在这里略有不同），总结一下：</p><ol><li>散点平滑</li><li>求散点导</li><li>散点导平滑</li><li>求极值</li><li>积分求面积</li></ol><p>下面逐条分析</p><h2 id="散点平滑"><a href="#散点平滑" class="headerlink" title="散点平滑"></a>散点平滑</h2><p>平滑就比较简单了，这里用了<code>均值滤波</code>，说白了就是前后求均值。</p><p>直接上代码吧，原理简单效果显著</p><pre><code class="c++">std::vector&lt;double&gt; blur(const std::vector&lt;double&gt;&amp; data, int kernel_size, double center_value){    std::vector&lt;double&gt; dst;    for (int i = 0; i != data.size(); ++i) {        // 均值滤波        double sum = data.at(i) * center_value;        double count = center_value;        for (int j = 1; j != kernel_size; ++j) {            if (i - j &gt;= 0) {                sum += data.at(i - j);                ++count;            }            if (i + j &lt; data.size()) {                sum += data.at(i + j);                ++count;            }        }        dst.push_back(sum / count);    }    return dst;}</code></pre><p><img src="/post_images/crest_2.png" alt="平滑曲线"></p><p>当然也可以尝试更高级的高斯滤波或者其他方法，有兴趣可以再研究一下。</p><h2 id="求散点导"><a href="#求散点导" class="headerlink" title="求散点导"></a>求散点导</h2><p>曲线拟合比较复杂，主要波形也不固定需要分段拟合，运行环境也不一定能上ml，所有还是手工用算法操作，这里使用的是<code>中间差分法</code>，具体的数学原理就不是我们研究的范围了，<a href="http://379910987.blog.163.com/blog/static/33523797201293125832513/" target="_blank" rel="noopener">公式</a>可以参考一下</p><pre><code class="c++">std::vector&lt;double&gt; derivative(const std::vector&lt;double&gt;&amp; data, const int h_value){    std::vector&lt;double&gt; dst;    for (int x = 2 * h_value; x != data.size() - (2 * h_value); ++x) {        double fx = (-data.at(x + 2 * h_value) + 8 * data.at(x + h_value) - 8 * data.at(x - h_value) + data.at(x - 2 * h_value)) / (12 * h_value);        dst.push_back(fx);    }    return dst;}</code></pre><p>这里没有对前后<code>2*h_value</code>进行计算，可以使用<code>向前差分</code>和<code>向后差分</code>进行完整的散点导数计算，由于我们的项目不需要，所以不做赘述</p><p><em>上面是重新调整参数后的平滑曲线，下面是已经平滑过的导函数曲线</em><br><img src="/post_images/crest_3.png" alt="导函数曲线"></p><h2 id="散点导平滑"><a href="#散点导平滑" class="headerlink" title="散点导平滑"></a>散点导平滑</h2><p>没什么好说的，将导数的数据再次进行平滑即可</p><h2 id="求极值"><a href="#求极值" class="headerlink" title="求极值"></a>求极值</h2><p>由于我们求出来的是散点导数，而不是导数方程，所以直接通过<code>f&#39;(x) == 0</code>判断并不合适（因为散点并不一定落在x轴上），但是导数点一定是两边异号，这样也就很好判断了，通过<code>f&#39;(x-x0) * f&#39;(x) &lt;= 0</code>即可。</p><pre><code class="c++">std::vector&lt;double&gt; extremum(const std::vector&lt;double&gt;&amp; data, int flag = 0){    std::vector&lt;double&gt; dst;    for (int i = 1; i != data.size(); ++i) {        // 左右异号，则为极值        if (data.at(i - 1) * data.at(i) &lt;= 0) {            if (flag &gt; 0) {                if (data.at(i - 1) &lt; 0 || data.at(i) &gt; 0) {                    continue;                }            } else if (flag &lt; 0) {                if (data.at(i - 1) &gt; 0 || data.at(i) &lt; 0) {                    continue;                }            }            else {  // flag == 0                ;            }            // 取离0近的那个            if (std::abs(data.at(i - 1)) &lt; std::abs(data.at(i))) {                dst.push_back(i - 1);            } else {                dst.push_back(i);            }        }    }    return dst;}</code></pre><p>代码中的<code>flag</code>参数用于仅取极大值或极小值。</p><h2 id="积分求面积"><a href="#积分求面积" class="headerlink" title="积分求面积"></a>积分求面积</h2><p><code>Σf(x-x0)</code>，x0即为要选择的底部，积分范围从上一个极小值到下一个极小值即可。</p><p>我们的需求比较特殊，需要取值区间宽度固定，由于以第一个波峰作为基准，所以取其上一个极小值到下一个极小值的宽度的比值（实际取了三分之一）</p><pre><code class="c++">double crest_area(const std::vector&lt;double&gt;&amp; data, const std::vector&lt;double&gt;&amp; extrem, int crest_index, int width_ratio = 3){    int width = (extrem.at(1) - extrem.at(0)) / width_ratio;    double bottom = data.at(extrem.at(1));    // 积分求面积    double area = 0;    for (int i = -width; i != width; ++i) {        area += data.at(extrem.at(i * 2)) - bottom;    }    return area;}</code></pre><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>依次调各个函数吧</p><pre><code class="c++">struct CrestRatioArg;std::vector&lt;double&gt; calc_crest_ratio(const std::vector&lt;double&gt;&amp; data, const CrestRatioArg &amp; arg){    auto blur_dst = blur(data, arg.kernel_size1, arg.center_value1);    auto dv_dst = derivative(blur_dst, arg.dv_h_value);    auto dv_blur_dst = blur(dv_dst, arg.kernel_size2, arg.center_value2);    auto full_extrem_dst = extremum(dv_blur_dst);    std::vector&lt;double&gt; result;        if (full_extrem_dst.empty()) {        return result;    }    double first_crest_area = crest_area(blur_dst, full_extrem_dst, 0, arg.integral_width_ratio);    if (first_crest_area == 0) {        return result;    }    for (int i = 1; i != full_extrem_dst.size() / 2 + 1; ++i) {        double current_area = crest_area(blur_dst, full_extrem_dst, i, arg.integral_width_ratio);        result.push_back(current_area / first_crest_area);    }    return result;}struct CrestRatioArg {    int kernel_size1 = 100;    int center_value1 = 1;    int dv_h_value = 100;    int kernel_size2 = 20;    int center_value2 = 1;    int integral_width_ratio = 3;};</code></pre>]]></content>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 算法 </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>QML中ListView访问子组件</title>
      <link href="/2018/06/12/QML%E4%B8%ADListView%E8%AE%BF%E9%97%AE%E5%AD%90%E7%BB%84%E4%BB%B6/"/>
      <content type="html"><![CDATA[<p>老规矩先上结论，通过<code>contentItem.children</code>访问即可</p><pre><code class="js">var obj = listview.contentItem.children[index]</code></pre><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写QML项目难免经常要用到<a href="https://doc-snapshots.qt.io/qt5-5.9/qml-qtquick-listview.html" target="_blank" rel="noopener"><code>ListView</code></a>，可是<code>ListView</code>却不像<code>Repeater</code>一样拥有<code>itemAt(index)</code>这样的方法，只有<code>itemAt(real x, real y)</code>，需要通过坐标值来得到子组件，而作为可以滑动的列表，坐标还得实时计算，这也太蠢了，我明明只是想遍历所有子组件而已！查了很多资料终于找到了答案，使用其基类<code>QQuickItem</code>里的方法即可，而不是<code>ListView</code>里面的，即上文摘要中提到的<code>contentItem</code></p><pre><code class="js">var obj = listview.contentItem.children[index]</code></pre><h2 id="举个简单的例子"><a href="#举个简单的例子" class="headerlink" title="举个简单的例子"></a>举个简单的例子</h2><pre><code class="js">ListView {    id: listview    model: 10    delegate: TextField {        function getText() {            return text;        }    }    function getAllText() {        var allText = [];        var children = listview.contentItem.children;        for (var i = 0; i != children.length; ++i) {            allText.push(children[i].getText());        }        return allText;    }}</code></pre><h2 id="要注意的一些问题"><a href="#要注意的一些问题" class="headerlink" title="要注意的一些问题"></a>要注意的一些问题</h2><h3 id="spacing带来的问题"><a href="#spacing带来的问题" class="headerlink" title="spacing带来的问题"></a>spacing带来的问题</h3><p>不知道<code>spacing</code>具体的实现是什么，类似于给列表加上一些有长宽的<code>Item</code>或者什么的，这都不是重点，重点是加上的这些<code>Item</code>之后循环访问会出现问题，所以需要判断一下，举个例子：</p><pre><code class="js">var children = listview.contentItem.children;for (var i = 0; i !== children.length; ++i) {    if (typeof children[i].getText !== &quot;function&quot;) {    // 或者 === &quot;undefined&quot;        continue;    }    allText.push(children[i].getText());}</code></pre><p>当然也可能有更好的方法，想到再补充吧</p><h2 id="利用model的方法"><a href="#利用model的方法" class="headerlink" title="利用model的方法"></a>利用model的方法</h2><h3 id="7月7日更新"><a href="#7月7日更新" class="headerlink" title="7月7日更新"></a>7月7日更新</h3><p>临时想到的方法，还没有进一步验证，可能需要加一些处理才能使用，仅供参考</p><pre><code class="js">for (var i in listview.model) {    allText.push(i[&quot;xxx&quot;]);}</code></pre>]]></content>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Qt </tag>
            
            <tag> QML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HC5761刷OpenWrt并配置多播小结</title>
      <link href="/2018/04/04/%E6%9E%81%E8%B4%B0%E5%88%B7OpenWrt%E5%B9%B6%E9%85%8D%E7%BD%AE%E5%A4%9A%E6%92%AD%E5%B0%8F%E7%BB%93/"/>
      <content type="html"><![CDATA[<p>这几天把公司宿舍的网络好好的折腾了一下，从平均10Mbps最高20Mbps勉强提升到了稳定30Mbps，总结一下心得</p><a id="more"></a><h2 id="获取Root"><a href="#获取Root" class="headerlink" title="获取Root"></a>获取Root</h2><p>云插件中安装<code>开发中模式</code>，好像还要关联微信什么的，GUI操作应该不困难，感觉没啥好说的，<del>其实是因为好久以前弄的具体的我不记得了</del></p><h2 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h2><p>注意以下命令行都是基于极贰（<code>HC5761</code>)，其他路由器同理，但需要改一下链接下载符合自己机型的文件不要直接复制</p><h3 id="连上极路由"><a href="#连上极路由" class="headerlink" title="连上极路由"></a>连上极路由</h3><pre><code class="bash">ssh -p 1022 root@192.168.1.1</code></pre><p>密码就是路由器的管理密码</p><h3 id="刷入Bootloader"><a href="#刷入Bootloader" class="headerlink" title="刷入Bootloader"></a>刷入Bootloader</h3><p>这里我们刷入<code>Breed</code>，一个很强大的Bootloader，想刷入其他的可以下载<a href="#相关链接">相关链接</a>中的其他文件</p><pre><code class="bash">cd /tmpwget https://breed.hackpascal.net/breed-mt7620-hiwifi-hc5761.binmtd write breed-mt7620-hiwifi-hc5761.bin u-boot</code></pre><h3 id="刷入固件"><a href="#刷入固件" class="headerlink" title="刷入固件"></a>刷入固件</h3><p>这里我们刷入<code>OpenWrt</code>，想刷入其他的可以下载<a href="#相关链接">相关链接</a>中的其他文件</p><pre><code class="bash">wget http://rssn.cn/roms/openwrt-ramips-mt7620a-hc5761-squashfs-sysupgrade.binsysupgrade -F -n openwrt-ramips-mt7620a-hc5761-squashfs-sysupgrade.bin</code></pre><p>好像是只有<code>sysupgrade.bin</code>的固件可以使用这个命令行刷入，其他的固件可以进入<code>Bootloader</code>刷，具体的步骤为</p><ol><li>断电关机</li><li>长按reset不放，同时通电，约5秒后松手</li><li>进入<a href="http://192.168.1.1" target="_blank" rel="noopener">http://192.168.1.1</a></li><li>选择<code>固件更新</code>-<code>固件</code>-上传固件并更新</li></ol><p>等待完成后重启，固件就刷好了</p><h3 id="多播设置"><a href="#多播设置" class="headerlink" title="多播设置"></a>多播设置</h3><p>待续。。。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><h3 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h3><ul><li><a href="https://breed.hackpascal.net/" target="_blank" rel="noopener">breed</a></li><li><a href="http://rssn.cn/roms/uboot/" target="_blank" rel="noopener">u-boot</a></li></ul><h3 id="Rom"><a href="#Rom" class="headerlink" title="Rom"></a>Rom</h3><ul><li><a href="http://rssn.cn/roms/" target="_blank" rel="noopener">OpenWrt</a></li><li><a href="http://opt.cn2qq.com/padavan/" target="_blank" rel="noopener">Padavan</a></li><li><a href="http://downloads.openwrt.org.cn/PandoraBox/" target="_blank" rel="noopener">PandoraBox</a></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/196a43b79c24" target="_blank" rel="noopener">极路由1、1s等机型刷OpenWrt–成为真正的极客- 简书</a></li><li><a href="http://www.right.com.cn/forum/thread-161906-1-1.html" target="_blank" rel="noopener">AR/QCA/MTK Breed，功能强大的多线程 Bootloader ,恩山无线论坛</a></li><li><a href="http://www.right.com.cn/forum/thread-161324-1-1.html" target="_blank" rel="noopener">改华硕[N14U N54U]5G 2G的7620老毛子Padavan固件(私人云储存 aria2 QOS) ,恩山无线论坛</a></li><li><a href="https://blog.csdn.net/lvshaorong/article/details/70568791" target="_blank" rel="noopener">OpenWrt路由器macvlan单线多拨的方法 - CSDN博客</a></li><li><a href="https://blog.csdn.net/lvshaorong/article/details/61916525" target="_blank" rel="noopener">OpwnWrt 路由器MWAN3多线多拨实现方法 - CSDN博客</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 路由器 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>记一次Ubuntu下失败的显卡驱动安装</title>
      <link href="/2018/03/18/%E8%AE%B0Ubuntu%E4%B8%8B%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85/"/>
      <content type="html"><![CDATA[<p>先上结论：<strong>Ubuntu 16.04 x64下，目前没有i3-8100的核显UHD630的驱动</strong>，所以别想了，加张独显吧！<br><a id="more"></a></p><p>从头说起，今天把办公室电脑的CPU和主板换了，从i3-7100升级到了i3-8100，想着Linux的驱动是一起上，应该是换完插上硬盘就能用的，结果正常开始，但是分辨率始终不对。只有1024*768一个选项，办公室的电脑有两个屏幕，也一直只能镜像显示不能分屏。</p><p>这还不简单改个分辨率不就得了，直接xrandr命令修改分辨率，却提示<code>failed to get size of gamma for output default</code>，查了很多教程，依旧无解。</p><p>点击上方状态栏上<code>关于计算机</code>，图形处理器没能正确识别（具体是什么不记得了，反正不是UHD630），遂想到驱动没有正确安装。Intel的核显也不是私有驱动，在<code>设置</code>-<code>软件和更新</code>-<code>附加驱动</code>中找不到可用驱动，按照网上教程安装了<code>intel graphics update tool</code>，<em>题外话，这货真是有毒，下载驱动奇慢无比，哪怕挂代理也经常下到一半断掉</em>，多次尝试最后提示成功，但设置仍没有中分辨率的选项，xrandr依旧报错。然后又反复卸载重装，装新版本（测试过最新版为2.0.3），反复重启等等，无果。</p><p>折腾了一晚上，万般无奈只能准备重装系统了，烧好了ubuntu的镜像，启动的时候图像想到了什么，点了<code>try ubuntu without installing</code>，果然进去分辨率也不对，只有1024*768。找同事电脑试了一下，<code>try ubuntu without installing</code>进去分辨率是正确的，ohshit还是驱动问题啊，压根就没有可以用的驱动。翻出了压箱底的一张GTS450，插上主板接上供电开机。分辨率一切正常，原先i3-7100的UHD630存在的次屏幕不能自动适配分辨率需要手动xrandr的问题也解决了。。虽说换个辣鸡独显性能可能要降一大半，不过毕竟不跑GPU运算，也不用这台电脑玩游戏，无所谓啦=。=</p><p>说到底还是Intel对Linux的支持不够友好，浪费了一晚上时间就很气吧- -</p>]]></content>
      
      
        <tags>
            
            <tag> 吐槽 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu下源码编译安装最新版Shadowsocks-Qt5</title>
      <link href="/2018/03/08/Ubuntu%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Shadowsocks-Qt5/"/>
      <content type="html"><![CDATA[<p>既然说好的打造技术博客，总得写点干货什么的，正好前些日子买个了新的ss服务，买完才注意到加密方式是<code>chacha20-ietf-poly1305</code>，再一看Shadowsocks-Qt5在Ubuntu的软件源里面最新版本只是2.9，不支持啊，于是只能自己研究一下怎么弄了，遇到了不少坑，和大家分享一下经验方法。</p><a id="more"></a><h2 id="卸载旧版本Shadowsocks-Qt5"><a href="#卸载旧版本Shadowsocks-Qt5" class="headerlink" title="卸载旧版本Shadowsocks-Qt5"></a>卸载旧版本<code>Shadowsocks-Qt5</code></h2><pre><code class="bash">sudo apt-get purge shadowsocks-qt5</code></pre><h2 id="安装libsodium"><a href="#安装libsodium" class="headerlink" title="安装libsodium"></a>安装<code>libsodium</code></h2><pre><code class="bash">sudo apt-get install libsodium-dev</code></pre><h2 id="安装libbotan-2-x"><a href="#安装libbotan-2-x" class="headerlink" title="安装libbotan-2.x"></a>安装<code>libbotan-2.x</code></h2><p>下载解压编译安装，没啥好说的，可以访问<a href="https://botan.randombit.net/releases/" target="_blank" rel="noopener">Botan-Index of release</a> 获取最新本版，虽说新版本好像也没啥用XD</p><pre><code class="bash">wget https://botan.randombit.net/releases/Botan-2.3.0.tgztar xvf Botan-2.3.0.tgzcd Botan-2.3.0./configure.pymakesudo make installsudo ldconfig</code></pre><h2 id="安装libQtShadowsocks"><a href="#安装libQtShadowsocks" class="headerlink" title="安装libQtShadowsocks"></a>安装<code>libQtShadowsocks</code></h2><pre><code class="bash">sudo apt-get install qt5-qmake qtbase5-dev libqrencode-dev libqtshadowsocks-dev libappindicator-dev libzbar-dev libbotan1.10-devgit clone https://github.com/shadowsocks/libQtShadowsocks.gitmkdir buildcd buildcmake ..makesudo make installsudo ldconfig</code></pre><p>如果软件源中没有libqtshadowsocks-dev，可以使用pip安装</p><pre><code class="bash">sudo apt-get install python-pipsudo pip install shadowsocks</code></pre><p>如果原先安装过Qt，可能会提示找不到Qt目录，导入环境变量，然后重新编译安装</p><pre><code class="bash">export LD_LIBRARY_PATH=/opt/Qt5.10.0/5.10.0/gcc_64/lib/rm -rf *    #删除build文件夹中文件cmake ..makesudo make installsudo ldconfig</code></pre><h2 id="安装Shadowsocks-Qt5"><a href="#安装Shadowsocks-Qt5" class="headerlink" title="安装Shadowsocks-Qt5"></a>安装<code>Shadowsocks-Qt5</code></h2><pre><code class="bash">sudo apt-get install qt5-qmake qtbase5-dev libqrencode-dev libqtshadowsocks-dev libappindicator-dev libzbar-dev libbotan1.10-devgit clone https://github.com/shadowsocks/shadowsocks-qt5.gitcd shadowsocks-qt5mkdir buildcd buildcmake ..makesudo make installsudo ldconfig</code></pre><p>如果提示找不到Qt目录，编辑<code>CMakeLists.txt</code>，加入一行并保存</p><pre><code class="cmake">set(CMAKE_PREFIX_PATH &quot;/opt/Qt5.10.0/5.10.0/gcc_64&quot;)</code></pre><p>然后重新编译安装</p><pre><code class="bash">rm -rf *    #删除build文件夹中文件cmake ..makesudo make installsudo ldconfig</code></pre><h2 id="启动ss-qt5"><a href="#启动ss-qt5" class="headerlink" title="启动ss-qt5"></a>启动<code>ss-qt5</code></h2><p>直接启动即可</p><pre><code class="bash">ss-qt5</code></pre><p>若提示</p><pre><code class="bash">ss-qt5: /usr/lib/x86_64-linux-gnu/libQt5DBus.so.5: version `Qt_5&#39; not found (required by ss-qt5)ss-qt5: /usr/lib/x86_64-linux-gnu/libQt5Network.so.5: version `Qt_5&#39; not found (required by ss-qt5)ss-qt5: /usr/lib/x86_64-linux-gnu/libQt5Gui.so.5: version `Qt_5&#39; not found (required by ss-qt5)ss-qt5: /usr/lib/x86_64-linux-gnu/libQt5Core.so.5: version `Qt_5.10&#39; not found (required by ss-qt5)ss-qt5: /usr/lib/x86_64-linux-gnu/libQt5Core.so.5: version `Qt_5&#39; not found (required by ss-qt5)ss-qt5: /usr/lib/x86_64-linux-gnu/libQt5Widgets.so.5: version `Qt_5&#39; not found (required by ss-qt5)</code></pre><p>则还是环境变量的问题，导入后重新启动即可</p><pre><code class="bash">export LD_LIBRARY_PATH=/opt/Qt5.10.0/5.10.0/gcc_64/libss-qt5</code></pre><p>启动后在<code>帮助</code>-<code>关于</code>查看一下版本号若是新版就ok了<br><img src="/post_images/ss-qt5.png" alt="ss-qt5"></p><p>这时手动添加一个新连接，就已经可以看到加密方式中有<code>chacha20-ietf-poly1305</code>选项了<br><img src="/post_images/ss-connect.png" alt="配置新连接"></p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>可以写个sh，放到桌面双击启动</p><pre><code class="bash">#/bin/bashexport LD_LIBRARY_PATH=/opt/Qt5.10.0/5.10.0/gcc_64/libss-qt5</code></pre><p>将<code>文件管理器</code>-<code>编辑</code>-<code>首选项</code>-<code>行为</code>-<code>可执行文本文件</code>修改为<code>打开可执行文本文件时运行它们</code>即可，别忘了给sh脚本执行权限哦<br><img src="/post_images/file-settings.png" alt="文件行为设置"></p><p>顺便说一下命令行中如何使用ss，以及<code>method chacha20-ietf-poly1305 not supported</code>咋解决</p><p>新建json文件，内容格式如下</p><pre><code class="json">{    &quot;server&quot;: &quot;1.2.3.4&quot;,    &quot;server_port&quot;: &quot;1234&quot;,    &quot;password&quot;: &quot;1234567&quot;    &quot;local_address&quot;: &quot;127.0.0.1&quot;,    &quot;local_port&quot;: 1080,    &quot;timeout&quot;:300,    &quot;method&quot;:&quot;chacha20-ietf-poly1305&quot;,    &quot;fast_open&quot;: false,    &quot;workers&quot;: 1&quot;}</code></pre><p>然后安装最新版本ss并从文件中配置启动即可</p><pre><code class="bash">sudo pip install https://github.com/shadowsocks/shadowsocks/archive/master.zip -Usslocal -c xxx.json</code></pre><p>想让命令走ss推荐使用<code>porxychains</code>，具体使用方法可以Google一下不再赘述</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/shadowsocks/shadowsocks-qt5/issues/595#issue" target="_blank" rel="noopener">Add support for chacha20-ietf-poly1305 #595</a></li><li><a href="http://www.lujza.me/kali-linux-%E4%B8%8B%E5%AE%89%E8%A3%85-shadowsocks-qt5-%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">Kali Linux 下安装 Shadowsocks-qt5 及使用教程</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello Hexo</title>
      <link href="/2018/03/07/Hello-World/"/>
      <content type="html"><![CDATA[<p>emmm，这大概就是第一篇博文了</p>]]></content>
      
      
        <tags>
            
            <tag> 吐槽 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
