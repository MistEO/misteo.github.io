<!DOCTYPE html>
<html style="display: none;" lang="zh">
    <head>
    <meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.5.6 -->
    <script>
        window.materialVersion = "1.5.6"
        // Delete localstorage with these tags
        window.oldVersion = [
            'codestartv1',
            '1.3.4',
            '1.4.0',
            '1.4.0b1',
            '1.5.0',
            '1.5.2',
            '1.5.5'
        ]
    </script>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">





    <link rel="dns-prefetch" href="https://imsun.github.io"/>



    <link rel="dns-prefetch" href="https://www.google-analytics.com"/>



    <link rel="dns-prefetch" href="https://fonts.googleapis.com"/>





    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!-- Title -->
    
    <title>
        
            安全的字符串拷贝strcpy_s的实现与理解 | 
        
        肝！
    </title>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/myfavicon.png">
    <link rel="icon" href="/img/myfavicon.png">

    <meta name="format-detection" content="telephone=no"/>
    <meta name="description" itemprop="description" content="在C标准库中提供了字符串拷贝函数strcpy，而微软则为为它提供了一个更安全的版本strcpy_s，其函数原型为
errno_t __cdecl strcpy_s(
    char*       _Destination,
    rsize_t     _SizeInBytes,
    char const* _Source
    );

分享下它的实现和一些个人理解">
    <meta name="keywords" content=",算法,C/C++,STL">
    <meta name="theme-color" content="#0097A7">

    <!-- Disable Fucking Bloody Baidu Tranformation -->
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.zhCN.js"></script>
        
    <![endif]-->

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(a){try{localStorage.removeItem(a)}catch(b){}};lsloader.setLS=function(a,c){try{localStorage.setItem(a,c)}catch(b){}};lsloader.getLS=function(a){var c="";try{c=localStorage.getItem(a)}catch(b){c=""}return c};versionString="/*"+(window.materialVersion||"unknownVersion")+"*/";lsloader.clean=function(){try{var b=[];for(var a=0;a<localStorage.length;a++){b.push(localStorage.key(a))}b.forEach(function(e){var f=lsloader.getLS(e);if(window.oldVersion){var d=window.oldVersion.reduce(function(g,h){return g||f.indexOf("/*"+h+"*/")!==-1},false);if(d){lsloader.removeLS(e)}}})}catch(c){}};lsloader.clean();lsloader.load=function(f,a,b,d){if(typeof b==="boolean"){d=b;b=undefined}d=d||false;b=b||function(){};var e;e=this.getLS(f);if(e&&e.indexOf(versionString)===-1){this.removeLS(f);this.requestResource(f,a,b,d);return}if(e){var c=e.split(versionString)[0];if(c!=a){console.log("reload:"+a);this.removeLS(f);this.requestResource(f,a,b,d);return}e=e.split(versionString)[1];if(d){this.jsRunSequence.push({name:f,code:e});this.runjs(a,f,e)}else{document.getElementById(f).appendChild(document.createTextNode(e));b()}}else{this.requestResource(f,a,b,d)}};lsloader.requestResource=function(b,e,a,c){var d=this;if(c){this.iojs(e,b,function(h,f,g){d.setLS(f,h+versionString+g);d.runjs(h,f,g)})}else{this.iocss(e,b,function(f){document.getElementById(b).appendChild(document.createTextNode(f));d.setLS(b,e+versionString+f)},a)}};lsloader.iojs=function(d,b,g){var a=this;a.jsRunSequence.push({name:b,code:""});try{var f=new XMLHttpRequest();f.open("get",d,true);f.onreadystatechange=function(){if(f.readyState==4){if((f.status>=200&&f.status<300)||f.status==304){if(f.response!=""){g(d,b,f.response);return}}a.jsfallback(d,b)}};f.send(null)}catch(c){a.jsfallback(d,b)}};lsloader.iocss=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.iofonts=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.runjs=function(f,c,e){if(!!c&&!!e){for(var b in this.jsRunSequence){if(this.jsRunSequence[b].name==c){this.jsRunSequence[b].code=e}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var a=document.createElement("script");a.appendChild(document.createTextNode(this.jsRunSequence[0].code));a.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(a);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else{if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var d=this;var a=document.createElement("script");a.src=this.jsRunSequence[0].path;a.type="text/javascript";this.jsRunSequence[0].status="loading";a.onload=function(){d.jsRunSequence.shift();if(d.jsRunSequence.length>0){d.runjs()}};document.body.appendChild(a)}}};lsloader.tagLoad=function(b,a){this.jsRunSequence.push({name:a,code:"",path:b,status:"failed"});this.runjs()};lsloader.jsfallback=function(c,b){if(!!this.jsnamemap[b]){return}else{this.jsnamemap[b]=b}for(var a in this.jsRunSequence){if(this.jsRunSequence[a].name==b){this.jsRunSequence[a].code="";this.jsRunSequence[a].status="failed";this.jsRunSequence[a].path=c}}this.runjs()};lsloader.cssfallback=function(e,c,b){if(!!this.cssnamemap[c]){return}else{this.cssnamemap[c]=1}var d=document.createElement("link");d.type="text/css";d.href=e;d.rel="stylesheet";d.onload=d.onerror=b;var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(d,a)};lsloader.runInlineScript=function(c,b){var a=document.getElementById(b).innerText;this.jsRunSequence.push({name:c,code:a});this.runjs()}})();</script>

    <!-- Import queue -->
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Import CSS -->
    
        <style id="material_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_css","/css/material.min.css?Z7a72R1E4SxzBKR/WGctOA==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
        <style id="style_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("style_css","/css/style.min.css?NKhlKQkXw/c66TR5p4wO+w==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>

        
            
                <style id="prettify_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("prettify_css","/css/prettify.min.css?zp8STOU9v89XWFEnN+6YmQ==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
                <style id="prettify_theme"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("prettify_theme","/css/prettify/github-v2.min.css?AfzKxt++K+/lhZBlSjnxwg==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
            
        

    

    

    <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
    overflow-x: hidden !important;
  }
  
  code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-color: #F5F5F5;
      }

      /* blog_info bottom background */
      #scheme-Paradox .material-layout .something-else .mdl-card__supporting-text{
        background-color: #fff;
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->
<!-- Import Roboto -->

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">


<!-- Import Material Icons -->


    <style id="material_icons"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_icons","/css/material-icons.css?pqhB/Rd/ab0H2+kZp0RDmw==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>




    <!-- Import jQuery -->
    
        <script>lsloader.load("jq_js","/js/jquery.min.js?qcusAULNeBksqffqUM2+Ig==", true)</script>
    

    <!-- WebAPP Icons -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="肝！">
    <meta name="msapplication-starturl" content="http://www.misteo.top/2020/10/21/安全的字符串拷贝strcpy-s的实现与理解/">
    <meta name="msapplication-navbutton-color" content="#0097A7">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="肝！">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/img/myfavicon.png">

    <!-- Site Verification -->
    
    

    <!-- RSS -->
    

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://www.misteo.top/2020/10/21/安全的字符串拷贝strcpy-s的实现与理解/">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="安全的字符串拷贝strcpy_s的实现与理解 | 肝！">
    <meta property="og:image" content="/img/myfavicon.png">
    <meta property="og:description" content="在C标准库中提供了字符串拷贝函数strcpy，而微软则为为它提供了一个更安全的版本strcpy_s，其函数原型为
errno_t __cdecl strcpy_s(
    char*       _Destination,
    rsize_t     _SizeInBytes,
    char const* _Source
    );

分享下它的实现和一些个人理解">
    <meta property="og:article:tag" content="算法"> <meta property="og:article:tag" content="C/C++"> <meta property="og:article:tag" content="STL"> 

    
        <meta property="article:published_time" content="Wed Oct 21 2020 15:29:00 GMT+0800">
        <meta property="article:modified_time" content="Mon Nov 30 2020 21:16:04 GMT+0800">
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:card" content="summary_large_image">

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="http://www.misteo.top/2020/10/21/安全的字符串拷贝strcpy-s的实现与理解/index.html" />
    

    <!-- Structured-data for SEO -->
    
        


<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": "http://www.misteo.top/2020/10/21/安全的字符串拷贝strcpy-s的实现与理解/index.html",
    "headline": "安全的字符串拷贝strcpy_s的实现与理解",
    "datePublished": "Wed Oct 21 2020 15:29:00 GMT+0800",
    "dateModified": "Mon Nov 30 2020 21:16:04 GMT+0800",
    "author": {
        "@type": "Person",
        "name": "MistEO",
        "image": {
            "@type": "ImageObject",
            "url": "/img/avatar.jpeg"
        },
        "description": "Hi, Nice to meet you"
    },
    "publisher": {
        "@type": "Organization",
        "name": "肝！",
        "logo": {
            "@type":"ImageObject",
            "url": "/img/myfavicon.png"
        }
    },
    "keywords": ",算法,C/C++,STL",
    "description": "在C标准库中提供了字符串拷贝函数strcpy，而微软则为为它提供了一个更安全的版本strcpy_s，其函数原型为
errno_t __cdecl strcpy_s(
    char*       _Destination,
    rsize_t     _SizeInBytes,
    char const* _Source
    );

分享下它的实现和一些个人理解",
}
</script>


    

    <!-- Analytics -->
    
        <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-115445722-1', 'auto');ga('send', 'pageview');
</script>
    
    
    

    <!-- Custom Head -->
    

</head>


    
        <body id="scheme-Paradox" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span id="MD-burger-id" class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->


    <!-- Left aligned menu below button -->
    
    
    <button id="post-toc-trigger-btn"
        class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh; overflow-y:scroll;">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#源码展示"><span class="post-toc-number">1.</span> <span class="post-toc-text">源码展示</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#标准strcpy的实现"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">标准strcpy的实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#微软strcpy-s的实现"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">微软strcpy_s的实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#详细分析过程"><span class="post-toc-number">2.</span> <span class="post-toc-text">详细分析过程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#总体猜测"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">总体猜测</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#VALIDATE-STRING"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">_VALIDATE_STRING</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#小结（-VALIDATE-STRING）"><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">小结（-VALIDATE-STRING）</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#VALIDATE-POINTER-RESET-STRING"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">_VALIDATE_POINTER_RESET_STRING</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#小结（-VALIDATE-POINTER-RESET-STRING）"><span class="post-toc-number">2.3.1.</span> <span class="post-toc-text">小结（-VALIDATE-POINTER-RESET-STRING）</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#RESET-STRING"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">_RESET_STRING</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#小结（-RESET-STRING）"><span class="post-toc-number">2.4.1.</span> <span class="post-toc-text">小结（-RESET-STRING）</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#RETURN-BUFFER-TOO-SMALL"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">_RETURN_BUFFER_TOO_SMALL</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#小结（-RETURN-BUFFER-TOO-SMALL）"><span class="post-toc-number">2.5.1.</span> <span class="post-toc-text">小结（-RETURN-BUFFER-TOO-SMALL）</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#FILL-STRING"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">_FILL_STRING</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#小结（-FILL-STRING）"><span class="post-toc-number">2.6.1.</span> <span class="post-toc-text">小结（-FILL-STRING）</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#RETURN-NO-ERROR"><span class="post-toc-number">2.7.</span> <span class="post-toc-text">_RETURN_NO_ERROR</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#小结（-RETURN-NO-ERROR）"><span class="post-toc-number">2.7.1.</span> <span class="post-toc-text">小结（-RETURN-NO-ERROR）</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#分析结论"><span class="post-toc-number">3.</span> <span class="post-toc-text">分析结论</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#简化实现"><span class="post-toc-number">4.</span> <span class="post-toc-text">简化实现</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#扩展延伸"><span class="post-toc-number">5.</span> <span class="post-toc-text">扩展延伸</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#strcat-s"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">strcat_s</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#strset-s"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">strset_s</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#进一步扩展"><span class="post-toc-number">6.</span> <span class="post-toc-text">进一步扩展</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#strtok-s"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">strtok_s</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#strncpy-s"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">strncpy_s</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#strncat-s"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">strncat_s</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#strnset-s"><span class="post-toc-number">6.4.</span> <span class="post-toc-text">strnset_s</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#参考资料"><span class="post-toc-number">7.</span> <span class="post-toc-text">参考资料</span></a></li></ol>
    </ul>
    




<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        
            <!-- Random Thumbnail -->
            <div class="post_thumbnail-random mdl-card__media mdl-color-text--grey-50">
            <script type="text/ls-javascript" id="post-thumbnail-script">
    var randomNum = Math.floor(Math.random() * 19 + 1);

    $('.post_thumbnail-random').attr('data-original', '/img/random/material-' + randomNum + '.png');
    $('.post_thumbnail-random').addClass('lazy');
</script>

        
    
            <p class="article-headline-p">
                安全的字符串拷贝strcpy_s的实现与理解
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/avatar.jpeg" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>MistEO</strong>
        <span>10月 21, 2020</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    

    <!-- Tags (bookmark) -->
    
    <button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
        <i class="material-icons" role="presentation">bookmark</i>
        <span class="visuallyhidden">bookmark</span>
    </button>
    <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button">
        <li class="mdl-menu__item">
        <a class="post_tag-link" href="/tags/C-C/">C/C++</a></li><li class="mdl-menu__item"><a class="post_tag-link" href="/tags/STL/">STL</a></li><li class="mdl-menu__item"><a class="post_tag-link" href="/tags/算法/">算法</a>
    </ul>
    

    <!-- Share -->
    
        <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    

    <!-- Share Weibo -->
    
        <a class="post_share-link" href="http://service.weibo.com/share/share.php?appkey=&title=安全的字符串拷贝strcpy_s的实现与理解&url=http://www.misteo.top/2020/10/21/安全的字符串拷贝strcpy-s的实现与理解/index.html&pic=http://www.misteo.top/img/myfavicon.png&searchPic=false&style=simple" target="_blank">
            <li class="mdl-menu__item">
                分享到微博
            </li>
        </a>
    

    <!-- Share Twitter -->
    

    <!-- Share Facebook -->
    

    <!-- Share Google+ -->
    
        <a class="post_share-link" href="https://plus.google.com/share?url=http://www.misteo.top/2020/10/21/安全的字符串拷贝strcpy-s的实现与理解/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Google+
            </li>
        </a>
    

    <!-- Share LinkedIn -->
    

    <!-- Share QQ -->
    
        <a class="post_share-link" href="http://connect.qq.com/widget/shareqq/index.html?site=肝！&title=安全的字符串拷贝strcpy_s的实现与理解&summary=MistEO的博客&pics=http://www.misteo.top/img/myfavicon.png&url=http://www.misteo.top/2020/10/21/安全的字符串拷贝strcpy-s的实现与理解/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 QQ
            </li>
        </a>
    

    <!-- Share Telegram -->
    
</ul>

    
</div>

                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    
        <p>在C标准库中提供了字符串拷贝函数<code>strcpy</code>，而微软则为为它提供了一个更安全的版本<code>strcpy_s</code>，其函数原型为</p>
<pre><code class="c++">errno_t __cdecl strcpy_s(
    char*       _Destination,
    rsize_t     _SizeInBytes,
    char const* _Source
    );
</code></pre>
<p>分享下它的实现和一些个人理解</p>
<a id="more"></a>
<h2 id="源码展示"><a href="#源码展示" class="headerlink" title="源码展示"></a>源码展示</h2><h3 id="标准strcpy的实现"><a href="#标准strcpy的实现" class="headerlink" title="标准strcpy的实现"></a>标准<code>strcpy</code>的实现</h3><pre><code class="c++">// from gcc-4.8.5
extern void abort (void);
extern int inside_main;

__attribute__ ((__noinline__))
char *
strcpy (char *d, const char *s)
{
  char *r = d;
#if defined __OPTIMIZE__ &amp;&amp; !defined __OPTIMIZE_SIZE__
  if (inside_main)
    abort ();
#endif
  while ((*d++ = *s++));
  return r;
}

// 简化一下
char *strcpy (char *d, const char *s)
{
  char *r = d;
  while ((*d++ = *s++));
  return r;
}
</code></pre>
<p><del>没什么好说的，懂得都懂（笑</del></p>
<p>逐地址拷贝，当<code>*d == &#39;\0&#39;</code>时，while循环退出结束拷贝，网上搜strcpy实现应该能找到很多详解，不赘述了</p>
<h3 id="微软strcpy-s的实现"><a href="#微软strcpy-s的实现" class="headerlink" title="微软strcpy_s的实现"></a>微软<code>strcpy_s</code>的实现</h3><pre><code class="c++">// from C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\crt\src\tcscpy_s.inl

/***
*tcscpy_s.inl - general implementation of _tcscpy_s
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the general algorithm for strcpy_s and its variants.
*
****/

_FUNC_PROLOGUE
errno_t __cdecl _FUNC_NAME(_CHAR *_DEST, size_t _SIZE, const _CHAR *_SRC)
{
    _CHAR *p;
    size_t available;

    /* validation section */
    _VALIDATE_STRING(_DEST, _SIZE);
    _VALIDATE_POINTER_RESET_STRING(_SRC, _DEST, _SIZE);

    p = _DEST;
    available = _SIZE;
    while ((*p++ = *_SRC++) != 0 &amp;&amp; --available &gt; 0)
    {
    }

    if (available == 0)
    {
        _RESET_STRING(_DEST, _SIZE);
        _RETURN_BUFFER_TOO_SMALL(_DEST, _SIZE);
    }
    _FILL_STRING(_DEST, _SIZE, _SIZE - available + 1);
    _RETURN_NO_ERROR;
}
</code></pre>
<p>首先明确一点，多出来的参数<code>size_t _SIZE</code>需要传入目的地址可用长度，即<code>_DEST</code>的可用长度</p>
<p>实现中多了几个宏定义，我们先<strong>猜一下</strong>他们是干嘛的，然后带着疑问往下看。</p>
<p>不感兴趣的同学也可以跳过这一章，直接看后面的<a href="#分析结论">分析结论</a></p>
<h2 id="详细分析过程"><a href="#详细分析过程" class="headerlink" title="详细分析过程"></a>详细分析过程</h2><p>（<em>注：以下为猜测内容，与实际可能有较大差异，正确解释请接着往后看每个宏定义的详细分析</em>）</p>
<h3 id="总体猜测"><a href="#总体猜测" class="headerlink" title="总体猜测"></a>总体猜测</h3><ul>
<li><code>_VALIDATE_STRING</code>：应该是验证字符串的合法性，是否为NULL，失败可能会直接return错误码；传入SIZE可能还会判断目的地址是否有这么长？但是这个咋判断呢，想不通</li>
<li><code>_VALIDATE_POINTER_RESET_STRING</code>：看不懂，不过既然是VALIDATE（验证），估计还是做一些什么检查之类的吧，但是后面为啥又RESET呢？</li>
<li><code>_RESET_STRING</code>：应该是将字符串重置，重置为NULL么？</li>
<li><code>_RETURN_BUFFER_TOO_SMALL</code>：应该就是return了一个错误码吧，可能还包含错误信息啥的？</li>
<li><code>_FILL_STRING</code>：应该是将字符串剩余部分填充为NULL？</li>
<li><code>_RETURN_NO_ERROR</code>：应该就是<code>return 0</code>。</li>
</ul>
<p>这样再看一遍代码下来，整体逻辑还是比较清晰的：</p>
<ol>
<li>先两个<code>_VALIDATE</code>宏，验证目的字符串和源字符串的合法性</li>
<li>开始逐字符拷贝，如果正常拷到<code>&#39;\0&#39;</code>，或者<code>available</code>跑完了，就停止</li>
<li>如果2.中是<code>available</code>跑完了，说明SRC的长度超过了SIZE，即超过了目的字符串最大可用长度。拷贝失败了，重置DEST，整理错误信息，return错误码。</li>
<li>正常拷到<code>&#39;\0&#39;</code>，就把DEST剩余的后半部分<code>[_SIZE - available + 1, _Size)</code>全填充为某个比较安全的值。</li>
<li>return 0 结束。</li>
</ol>
<p>下面逐个分析下这些宏，为了便于理解，我整理了一下，不要在意定义的先后顺序~</p>
<h3 id="VALIDATE-STRING"><a href="#VALIDATE-STRING" class="headerlink" title="_VALIDATE_STRING"></a><code>_VALIDATE_STRING</code></h3><pre><code class="c++">_VALIDATE_STRING(_DEST, _SIZE);

// from internal_securecrt.h
#define _VALIDATE_STRING(_String, _Size) \
    _VALIDATE_STRING_ERROR((_String), (_Size), EINVAL)
</code></pre>
<p>得，套娃，我们接着看</p>
<pre><code class="c++">// from internal_securecrt.h
#define _VALIDATE_STRING_ERROR(_String, _Size, _Ret) \
    _VALIDATE_RETURN((_String) != NULL &amp;&amp; (_Size) &gt; 0, EINVAL, (_Ret))

// from errno.h
#define EINVAL          22
</code></pre>
<p>似乎好理解一点了，如果不满足<code>(_String) != NULL &amp;&amp; (_Size) &gt; 0</code>，可能会报错并返回<code>EINVAL</code>，<code>EINVAL</code>就是errno的错误码<code>22</code>，表示非法参数。原来Size只是判断是否大于0啊，那看来前面猜测的判断DEST长度是猜错了，确实没法实现这个</p>
<p>但是<code>_VALIDATE_RETURN</code>的第二个和第三个参数都是<code>EINVAL</code>，又是干啥的？</p>
<pre><code class="c++">// from internal.h
#ifndef _VALIDATE_RETURN
#define _VALIDATE_RETURN( expr, errorcode, retexpr )                           \
    {                                                                          \
        int _Expr_val=!!(expr);                                                \
        _ASSERT_EXPR( ( _Expr_val ), _CRT_WIDE(#expr) );                       \
        if ( !( _Expr_val ) )                                                  \
        {                                                                      \
            errno = errorcode;                                                 \
            _INVALID_PARAMETER(_CRT_WIDE(#expr) );                             \
            return ( retexpr );                                                \
        }                                                                      \
    }
#endif  /* _VALIDATE_RETURN */
</code></pre>
<p>首先看明白了上面的疑问，第一个参数<code>expr</code>是判断条件，第二个参数<code>errorcode</code>是赋值给errno的（不了解errno的同学可以自行搜一下），第三个参数<code>retexpr</code>是用来return的</p>
<p>然后我们接着来看套娃</p>
<pre><code class="c++">// from crtdbg.h
#ifndef _DEBUG
    #ifndef _ASSERT_EXPR
        #define _ASSERT_EXPR(expr, msg) ((void)0)
    #endif  
#else // ^^^ !_DEBUG ^^^ // vvv _DEBUG vvv //

    // !! is used to ensure that any overloaded operators used to evaluate expr
    // do not end up at &amp;&amp;.
    #ifndef _ASSERT_EXPR
        #define _ASSERT_EXPR(expr, msg) \
            (void)(                                                                                     \
                (!!(expr)) ||                                                                           \
                (1 != _CrtDbgReportW(_CRT_ASSERT, _CRT_WIDE(__FILE__), __LINE__, NULL, L&quot;%ls&quot;, msg)) || \
                (_CrtDbgBreak(), 0)                                                                     \
            )
    #endif
</code></pre>
<p>非Debug模式下，就什么也不做，直接转<code>((void)0)</code>；Debug模式下，<code>_CrtDbgReportW</code>是弹出对话框报错，<code>_CrtDbgBreak</code>是触发调试断点，这个扯远了，不再深度展开，有兴趣的同学再另外看下吧~</p>
<pre><code class="c++">// from internal.h
#define _INVALID_PARAMETER(expr) _CALL_INVALID_PARAMETER(expr)

// from internal.h
#define _CALL_INVALID_PARAMETER(expr) _invalid_parameter(expr, __FUNCTIONW__, __FILEW__, __LINE__, 0)
</code></pre>
<p><code>_INVALID_PARAMETER</code>说实话我真没太看明白在干嘛，继续追踪后来会到<code>invarg.c</code>中，套娃套的太多了，看不过来了。。获取了<code>__FUNCTION__</code>、<code>__LINE__</code>等，估计是记录错误，可能在VS的调试器等中有体现，有兴趣的同学也自行也就看下吧</p>
<h4 id="小结（-VALIDATE-STRING）"><a href="#小结（-VALIDATE-STRING）" class="headerlink" title="小结（-VALIDATE-STRING）"></a>小结（-VALIDATE-STRING）</h4><p>总结一下，就是检查<code>(_DEST != NULL &amp;&amp; _Size &gt; 0)</code>，不满足的话，赋值errno，并直接返回错误码，（_DEBUG模式下，还会弹窗提示，并触发调试断点）。简单实现如下</p>
<pre><code class="c++">// Same like _VALIDATE_STRING(_DEST, _SIZE);
if (_DEST == NULL || _Size &lt;= 0)
{
    errno = EINVAL;
    return EINVAL;
}
</code></pre>
<p>看完了第一个宏，想必对这些宏的套路也有一些了解，后面的就不每个这么详细展开了</p>
<h3 id="VALIDATE-POINTER-RESET-STRING"><a href="#VALIDATE-POINTER-RESET-STRING" class="headerlink" title="_VALIDATE_POINTER_RESET_STRING"></a><code>_VALIDATE_POINTER_RESET_STRING</code></h3><pre><code class="c++">_VALIDATE_POINTER_RESET_STRING(_SRC, _DEST, _SIZE);

// from internal_securecrt.h
#define _VALIDATE_POINTER_RESET_STRING(_Pointer, _String, _Size) \
    _VALIDATE_POINTER_RESET_STRING_ERROR((_Pointer), (_String), (_Size), EINVAL)

// from internal_securecrt.h
#define _VALIDATE_POINTER_RESET_STRING_ERROR(_Pointer, _String, _Size, _Ret) \
    if ((_Pointer) == NULL) \
    { \
        _RESET_STRING((_String), (_Size)); \
        _VALIDATE_POINTER_ERROR_RETURN((_Pointer), EINVAL, (_Ret)) \
    }
</code></pre>
<p>如果<code>_SRC</code>为<code>NULL</code>，才进行<code>_RESET_STRING</code>和<code>_VALIDATE_POINTER_ERROR_RETURN</code>的操作，就是如果源字符串NULL，直接把目的字符串重置，然后返回验证一个什么值并返回</p>
<pre><code class="c++">// from internal_securecrt.h
#define _RESET_STRING(_String, _Size) \
    *(_String) = 0; \
    _FILL_STRING((_String), (_Size), 1);

// from internal_securecrt.h
/* string resetting */
#define _FILL_STRING _SECURECRT__FILL_STRING

// from internal.h
#if _SECURECRT_FILL_BUFFER
#define _SECURECRT__FILL_STRING(_String, _Size, _Offset)                            \
    if ((_Size) != ((size_t)-1) &amp;&amp; (_Size) != INT_MAX &amp;&amp;                            \
        ((size_t)(_Offset)) &lt; (_Size))                                              \
    {                                                                               \
        memset((_String) + (_Offset),                                               \
            _SECURECRT_FILL_BUFFER_PATTERN,                                         \
            (_SECURECRT_FILL_BUFFER_THRESHOLD &lt; ((size_t)((_Size) - (_Offset))) ?   \
                _SECURECRT_FILL_BUFFER_THRESHOLD :                                  \
                ((_Size) - (_Offset))) * sizeof(*(_String)));                       \
    }
#else  /* _SECURECRT_FILL_BUFFER */
#define _SECURECRT__FILL_STRING(_String, _Size, _Offset)
#endif  /* _SECURECRT_FILL_BUFFER */

// from internal.h
#ifdef _DEBUG
#define _SECURECRT_FILL_BUFFER 1
#else  /* _DEBUG */
#define _SECURECRT_FILL_BUFFER 0
#endif  /* _DEBUG */

// from corecrt.h, 0xFE = 254
#define _SECURECRT_FILL_BUFFER_PATTERN 0xFE

// from internal.h
#ifdef _DEBUG
#define _SECURECRT_FILL_BUFFER_THRESHOLD __crtDebugFillThreshold
#else  /* _DEBUG */
#define _SECURECRT_FILL_BUFFER_THRESHOLD ((size_t)0)
#endif  /* _DEBUG */

// from dbgheap.c
extern &quot;C&quot; size_t __crtDebugFillThreshold = SIZE_MAX;
</code></pre>
<p>这里比较巧妙，重置字符串，一般情况下仅将_DSET首个char的值赋值 <code>*(_DEST) = 0;</code>；DEBUG模式下才<code>_FILL_STRING</code>，其中还用<code>_SECURECRT_FILL_BUFFER_THRESHOLD</code>长度判断，还是跟着DEBUG走的，用memset将后面剩下的char赋值为254。后面在<code>_FILL_STRING</code>章节详细论述一下这个</p>
<pre><code class="c++">// from internal_securecrt.h
#define _VALIDATE_POINTER_ERROR_RETURN(_Pointer, _ErrorCode, _Ret) \
    _VALIDATE_RETURN((_Pointer) != NULL, (_ErrorCode), (_Ret))
</code></pre>
<h4 id="小结（-VALIDATE-POINTER-RESET-STRING）"><a href="#小结（-VALIDATE-POINTER-RESET-STRING）" class="headerlink" title="小结（-VALIDATE-POINTER-RESET-STRING）"></a>小结（-VALIDATE-POINTER-RESET-STRING）</h4><p>上个宏检查DEST，这个宏检查<code>_SRC != NULL</code>，不满足则将DEST首个字符的值赋0，DEBUG模式下会有一套更安全但是更耗性能的DEST重置方式，放在后面<code>_FILL_STRING</code>的时候一起写</p>
<pre><code class="c++">// Same like _VALIDATE_POINTER_RESET_STRING(_SRC, _DEST, _SIZE);
if (_SRC == NULL) {
    *_DEST = 0;
#ifdef _DEBUG
    _FILL_STRING(_DEST, _SIZE, 1);
#endif
    errno = EINVAL;
    return EINVAL;
}
</code></pre>
<h3 id="RESET-STRING"><a href="#RESET-STRING" class="headerlink" title="_RESET_STRING"></a><code>_RESET_STRING</code></h3><pre><code class="c++">_RESET_STRING(_DEST, _SIZE);

// from internal_securecrt.h
#define _RESET_STRING(_String, _Size) \
    *(_String) = 0; \
    _FILL_STRING((_String), (_Size), 1);
</code></pre>
<p>上面已经套娃过这个宏了，不再赘述</p>
<h4 id="小结（-RESET-STRING）"><a href="#小结（-RESET-STRING）" class="headerlink" title="小结（-RESET-STRING）"></a>小结（-RESET-STRING）</h4><p>同样_DEBUG的时候，更安全的重置方式，放在后面<code>_FILL_STRING</code>的时候一起写</p>
<pre><code class="c++">// Same like _RESET_STRING(_DEST, _SIZE);
*_DEST = 0;
#ifdef _DEBUG
    _FILL_STRING(_DEST, _SIZE, 1);
#endif
</code></pre>
<h3 id="RETURN-BUFFER-TOO-SMALL"><a href="#RETURN-BUFFER-TOO-SMALL" class="headerlink" title="_RETURN_BUFFER_TOO_SMALL"></a><code>_RETURN_BUFFER_TOO_SMALL</code></h3><pre><code class="c++">_RETURN_BUFFER_TOO_SMALL(_DEST, _SIZE);

// from internal_securecrt.h
#define _RETURN_BUFFER_TOO_SMALL(_String, _Size) \
    _RETURN_BUFFER_TOO_SMALL_ERROR((_String), (_Size), ERANGE)

// from internal_securecrt.h
#define _RETURN_BUFFER_TOO_SMALL_ERROR(_String, _Size, _Ret) \
    _VALIDATE_RETURN((L&quot;Buffer is too small&quot; &amp;&amp; 0), ERANGE, _Ret)

// from errno.h
#define ERANGE          34
</code></pre>
<h4 id="小结（-RETURN-BUFFER-TOO-SMALL）"><a href="#小结（-RETURN-BUFFER-TOO-SMALL）" class="headerlink" title="小结（-RETURN-BUFFER-TOO-SMALL）"></a>小结（-RETURN-BUFFER-TOO-SMALL）</h4><pre><code class="c++">// Same like _RETURN_BUFFER_TOO_SMALL(_DEST, _SIZE);
errno = ERANGE;
return ERANGE;
</code></pre>
<h3 id="FILL-STRING"><a href="#FILL-STRING" class="headerlink" title="_FILL_STRING"></a><code>_FILL_STRING</code></h3><p>终于讲到前面反复提及的_FILL_STRING了，其实也并没有很复杂，先看下定义</p>
<pre><code class="c++">// from internal_securecrt.h
/* string resetting */
#define _FILL_STRING _SECURECRT__FILL_STRING

// from internal.h
#if _SECURECRT_FILL_BUFFER
#define _SECURECRT__FILL_STRING(_String, _Size, _Offset)                            \
    if ((_Size) != ((size_t)-1) &amp;&amp; (_Size) != INT_MAX &amp;&amp;                            \
        ((size_t)(_Offset)) &lt; (_Size))                                              \
    {                                                                               \
        memset((_String) + (_Offset),                                               \
            _SECURECRT_FILL_BUFFER_PATTERN,                                         \
            (_SECURECRT_FILL_BUFFER_THRESHOLD &lt; ((size_t)((_Size) - (_Offset))) ?   \
                _SECURECRT_FILL_BUFFER_THRESHOLD :                                  \
                ((_Size) - (_Offset))) * sizeof(*(_String)));                       \
    }
#else  /* _SECURECRT_FILL_BUFFER */
#define _SECURECRT__FILL_STRING(_String, _Size, _Offset)
#endif  /* _SECURECRT_FILL_BUFFER */

// from internal.h
#ifdef _DEBUG
#define _SECURECRT_FILL_BUFFER 1
#else  /* _DEBUG */
#define _SECURECRT_FILL_BUFFER 0
#endif  /* _DEBUG */

// from corecrt.h, 0xFE = 254
#define _SECURECRT_FILL_BUFFER_PATTERN 0xFE

// from internal.h
#ifdef _DEBUG
#define _SECURECRT_FILL_BUFFER_THRESHOLD __crtDebugFillThreshold
#else  /* _DEBUG */
#define _SECURECRT_FILL_BUFFER_THRESHOLD ((size_t)0)
#endif  /* _DEBUG */

// from dbgheap.c
extern &quot;C&quot; size_t __crtDebugFillThreshold = SIZE_MAX;
</code></pre>
<p><code>_FILL_STRING</code>整个宏，仅在_DEBUG定义时work，否则什么也不做；</p>
<p><code>_SECURECRT__FILL_STRING(_String, _Size, _Offset)</code><br>三个参数很好理解，目的字符串、目的字符串长度、填充的起始偏移量</p>
<p><code>if ((_Size) != ((size_t)-1) &amp;&amp; (_Size) != INT_MAX &amp;&amp; ((size_t)(_Offset)) &lt; (_Size))</code><br>就是检查_Size合法性，并且要求_Offset小于_Size</p>
<p>然后<code>memset</code>从<code>(_String) + (_Offset)</code>地址开始，填充<code>0xFE</code>。非DEBUG模式下填充0个字节，还是相当于什么也不做，多一重判断；DEBUG模式下填充<code>(_Size - _Offset) * sizeof(char)</code>。</p>
<h4 id="小结（-FILL-STRING）"><a href="#小结（-FILL-STRING）" class="headerlink" title="小结（-FILL-STRING）"></a>小结（-FILL-STRING）</h4><pre><code class="c++">// Same like _FILL_STRING(_DEST, _SIZE, _OFFSET);
#ifdef _DEBUG
    if (_OFFSET &lt; _Size)
    {
        memset(_DEST + _OFFSET, 0xFE, (_Size - _Offset) * sizeof(char));
    }
#else
// Do nothing;
#endif
</code></pre>
<h3 id="RETURN-NO-ERROR"><a href="#RETURN-NO-ERROR" class="headerlink" title="_RETURN_NO_ERROR"></a><code>_RETURN_NO_ERROR</code></h3><pre><code class="c++">// from internal_securecrt.h
/* returns without calling _invalid_parameter */
#define _RETURN_NO_ERROR \
    return 0
</code></pre>
<p>终于有一个不套娃的了XD</p>
<h4 id="小结（-RETURN-NO-ERROR）"><a href="#小结（-RETURN-NO-ERROR）" class="headerlink" title="小结（-RETURN-NO-ERROR）"></a>小结（-RETURN-NO-ERROR）</h4><pre><code class="c++">// Same like _RETURN_NO_ERROR;
return 0;
</code></pre>
<h2 id="分析结论"><a href="#分析结论" class="headerlink" title="分析结论"></a>分析结论</h2><p>再粘一遍源码，方便对照着看</p>
<pre><code class="c++">_FUNC_PROLOGUE
errno_t __cdecl _FUNC_NAME(_CHAR *_DEST, size_t _SIZE, const _CHAR *_SRC)
{
    _CHAR *p;
    size_t available;

    /* validation section */
    _VALIDATE_STRING(_DEST, _SIZE);
    _VALIDATE_POINTER_RESET_STRING(_SRC, _DEST, _SIZE);

    p = _DEST;
    available = _SIZE;
    while ((*p++ = *_SRC++) != 0 &amp;&amp; --available &gt; 0)
    {
    }

    if (available == 0)
    {
        _RESET_STRING(_DEST, _SIZE);
        _RETURN_BUFFER_TOO_SMALL(_DEST, _SIZE);
    }
    _FILL_STRING(_DEST, _SIZE, _SIZE - available + 1);
    _RETURN_NO_ERROR;
}
</code></pre>
<ol>
<li><code>_VALIDATE_STRING(_DEST, _SIZE);</code> 检验<code>_DEST != NULL &amp;&amp; _Size &gt; 0</code>是否满足；若为假，则<code>errno = EINVAL</code>，并直接<code>return EINVAL</code>；如果是在Debug模式下（<code>_DEBUG</code>宏被定义过）还会弹出提示窗口、触发调试断点、记录下错误发生位置等</li>
<li><code>_VALIDATE_POINTER_RESET_STRING(_SRC, _DEST, _SIZE);</code> 判断<code>_SRC == NULL</code>是否满足；若为真，则Reset <code>_DEST</code>，<code>errno = EINVAL</code>，并直接<code>return EINVAL</code>，Debug模式下也同样弹窗、断点、错误等</li>
<li>算法逻辑：与分析中的没有区别，逐字符拷贝，如果正常拷到<code>&#39;\0&#39;</code>，或者<code>available</code>跑完了，就停止</li>
<li>如果<code>available == 0</code>，说明<code>_SRC</code>的长度超过了<code>_SIZE</code>，即超过了目的字符串最大可用长度，拷贝失败。</li>
<li><code>_RESET_STRING(_DEST, _SIZE);</code> 重置字符串，<code>*_DEST = 0;</code>，且<code>_FILL_STRING(_DEST, _SIZE, 1);</code>。即将首个字符赋值为<code>&#39;\0&#39;</code>，后面的字符填充安全字符<code>0xFE</code>。需要说明的是，<code>_FILL_STRING</code>也仅在Debug模式下才进行，否则什么也不处理</li>
<li><code>_RETURN_BUFFER_TOO_SMALL(_DEST, _SIZE);</code> <code>errno = ERANGE</code>，并直接<code>return ERANGE</code>，Debug模式下也同样弹窗、断点、错误等</li>
<li><code>_FILL_STRING(_DEST, _SIZE, _SIZE - available + 1);</code>就是调用<code>memset</code>，将<code>_DEST</code>比<code>_SRC</code>多出来的部分（<code>[_SIZE - available + 1, _Size)</code>）全部填充为安全字符<code>0xFE</code>。同样，<code>_FILL_STRING</code>也仅在Debug模式下才进行，否则什么也不处理</li>
</ol>
<p>可能有点绕，接着看下一章节简化实现应该就清晰了~</p>
<h2 id="简化实现"><a href="#简化实现" class="headerlink" title="简化实现"></a>简化实现</h2><p>看完了源码，我们来写个简单点的strcpy_s吧</p>
<pre><code class="c++">void fill_string(char * string, size_t size, size_t offset);

errno_t strcpy_s(char *_DEST, size_t _SIZE, const char *_SRC)
{
    char *p;
    size_t available;

    if (!(_DEST != NULL &amp;&amp; _Size &gt; 0))
    {
        errno = EINVAL;
        return EINVAL;
    }
    if (_SRC == NULL) {
        *_DEST = 0;
        fill_string(_DEST, _SIZE, 1);
        errno = EINVAL;
        return EINVAL;
    }

    p = _DEST;
    available = _SIZE;
    while ((*p++ = *_SRC++) != 0 &amp;&amp; --available &gt; 0)
    {
    }

    if (available == 0)
    {
        *_DEST = 0;
        fill_string(_DEST, _SIZE, 1);
        errno = ERANGE;
        return ERANGE;
    }
    fill_string(_DEST, _SIZE, _SIZE - available + 1);
    return 0;
}

inline void fill_string(char * string, size_t size, size_t offset)
{
#ifdef _DEBUG
    if (offset &lt; size)
    {
        memset(string + offset, 0xFE, (size - offset) * sizeof(char));
    }
#else
    // do nothing
    ;
#endif
}
</code></pre>
<h2 id="扩展延伸"><a href="#扩展延伸" class="headerlink" title="扩展延伸"></a>扩展延伸</h2><p>既然讲完了<code>strcpy_s</code>，那其他的字符串操作函数的<code>_safe</code>版本呢？下面再看下<code>strcat_s</code>和<code>strset_s</code>。也不多啰嗦了，直接粘出没见过的宏的实现，然后我们在写个简化实现看下~</p>
<h3 id="strcat-s"><a href="#strcat-s" class="headerlink" title="strcat_s"></a><code>strcat_s</code></h3><pre><code class="c++">/***
*tcscat_s.inl - general implementation of _tcscpy_s
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the general algorithm for strcat_s and its variants.
*
****/

_FUNC_PROLOGUE
errno_t __cdecl _FUNC_NAME(_CHAR *_DEST, size_t _SIZE, const _CHAR *_SRC)
{
    _CHAR *p;
    size_t available;

    /* validation section */
    _VALIDATE_STRING(_DEST, _SIZE);
    _VALIDATE_POINTER_RESET_STRING(_SRC, _DEST, _SIZE);

    p = _DEST;
    available = _SIZE;
    while (available &gt; 0 &amp;&amp; *p != 0)
    {
        p++;
        available--;
    }

    if (available == 0)
    {
        _RESET_STRING(_DEST, _SIZE);
        _RETURN_DEST_NOT_NULL_TERMINATED(_DEST, _SIZE);
    }

    while ((*p++ = *_SRC++) != 0 &amp;&amp; --available &gt; 0)
    {
    }

    if (available == 0)
    {
        _RESET_STRING(_DEST, _SIZE);
        _RETURN_BUFFER_TOO_SMALL(_DEST, _SIZE);
    }
    _FILL_STRING(_DEST, _SIZE, _SIZE - available + 1);
    _RETURN_NO_ERROR;
}
</code></pre>
<p>没见过的宏：</p>
<pre><code class="c++">// from internal_securecrt.h
#define _RETURN_DEST_NOT_NULL_TERMINATED(_String, _Size) \
    _VALIDATE_RETURN((L&quot;String is not null terminated&quot; &amp;&amp; 0), EINVAL, EINVAL)

</code></pre>
<p>简化实现：</p>
<pre><code class="c++">void fill_string(char * string, size_t size, size_t offset);

errno_t strcat_s(char *_DEST, size_t _SIZE, const char *_SRC)
{
    char *p;
    size_t available;

    if (!(_DEST != NULL &amp;&amp; _Size &gt; 0))
    {
        errno = EINVAL;
        return EINVAL;
    }
    if (_SRC == NULL) {
        *_DEST = 0;
        fill_string(_DEST, _SIZE, 1);
        errno = EINVAL;
        return EINVAL;
    }

    p = _DEST;
    available = _SIZE;
    while (available &gt; 0 &amp;&amp; *p != 0)
    {
        p++;
        available--;
    }

    if (available == 0)
    {
        *_DEST = 0;
        fill_string(_DEST, _SIZE, 1);
        errno = EINVAL;
        return EINVAL;
    }

    while ((*p++ = *_SRC++) != 0 &amp;&amp; --available &gt; 0)
    {
    }

    if (available == 0)
    {
        *_DEST = 0;
        fill_string(_DEST, _SIZE, 1);
        errno = ERANGE;
        return ERANGE;
    }
    fill_string(_DEST, _SIZE, _SIZE - available + 1);
    return 0;
}

inline void fill_string(char * string, size_t size, size_t offset)
{
#ifdef _DEBUG
    if (offset &lt; size)
    {
        memset(string + offset, 0xFE, (size - offset) * sizeof(char));
    }
#else
    // do nothing
    ;
#endif
</code></pre>
<h3 id="strset-s"><a href="#strset-s" class="headerlink" title="strset_s"></a><code>strset_s</code></h3><pre><code class="c++">/***
*tcsset_s.inl - general implementation of _tcsset_s
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the general algorithm for _strset_s and its variants.
*
****/

_FUNC_PROLOGUE
errno_t __cdecl _FUNC_NAME(_CHAR *_DEST, size_t _SIZE, _CHAR_INT _Value)
{
    _CHAR *p;
    size_t available;

    /* validation section */
    _VALIDATE_STRING(_DEST, _SIZE);

    p = _DEST;
    available = _SIZE;
    while (*p != 0 &amp;&amp; --available &gt; 0)
    {
        *p++ = (_CHAR)_Value;
    }

    if (available == 0)
    {
        _RESET_STRING(_DEST, _SIZE);
        _RETURN_DEST_NOT_NULL_TERMINATED(_DEST, _SIZE);
    }
    _FILL_STRING(_DEST, _SIZE, _SIZE - available + 1);
    _RETURN_NO_ERROR;
}
</code></pre>
<p>简化实现：</p>
<pre><code class="c++">void fill_string(char * string, size_t size, size_t offset);

errno_t strset_s(char *_DEST, size_t _SIZE, int _Value)
{
    char *p;
    size_t available;

    if (!(_DEST != NULL &amp;&amp; _Size &gt; 0))
    {
        errno = EINVAL;
        return EINVAL;
    }

    p = _DEST;
    available = _SIZE;
    while (*p != 0 &amp;&amp; --available &gt; 0)
    {
        *p++ = (char)_Value;
    }

    if (available == 0)
    {
        *_DEST = 0;
        fill_string(_DEST, _SIZE, 1);
        errno = EINVAL;
        return EINVAL;
    }
    fill_string(_DEST, _SIZE, _SIZE - available + 1);
    return 0;
}

inline void fill_string(char * string, size_t size, size_t offset)
{
#ifdef _DEBUG
    if (offset &lt; size)
    {
        memset(string + offset, 0xFE, (size - offset) * sizeof(char));
    }
#else
    // do nothing
    ;
#endif
}
</code></pre>
<h2 id="进一步扩展"><a href="#进一步扩展" class="headerlink" title="进一步扩展"></a>进一步扩展</h2><p>聊完了普通版本的_Safe版本string函数，再进一步扩展下所有的string函数safe版本</p>
<p>肝力有限，先把微软的实现粘出来，有空再更新吧</p>
<h3 id="strtok-s"><a href="#strtok-s" class="headerlink" title="strtok_s"></a><code>strtok_s</code></h3><pre><code class="c++">/***
*tcstok_s.inl - general implementation of _tcstok_s
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the general algorithm for strtok_s and its variants.
*
****/

_FUNC_PROLOGUE
_CHAR * __cdecl _FUNC_NAME(_CHAR *_String, const _CHAR *_Control, _CHAR **_Context)
{
    _CHAR *token;
    const _CHAR *ctl;

    /* validation section */
    _VALIDATE_POINTER_ERROR_RETURN(_Context, EINVAL, NULL);
    _VALIDATE_POINTER_ERROR_RETURN(_Control, EINVAL, NULL);
    _VALIDATE_CONDITION_ERROR_RETURN(_String != NULL || *_Context != NULL, EINVAL, NULL);

    /* If string==NULL, continue with previous string */
    if (!_String)
    {
        _String = *_Context;
    }

    /* Find beginning of token (skip over leading delimiters). Note that
    * there is no token iff this loop sets string to point to the terminal null. */
    for ( ; *_String != 0 ; _String++)
    {
        for (ctl = _Control; *ctl != 0 &amp;&amp; *ctl != *_String; ctl++)
            ;
        if (*ctl == 0)
        {
            break;
        }
    }

    token = _String;

    /* Find the end of the token. If it is not the end of the string,
    * put a null there. */
    for ( ; *_String != 0 ; _String++)
    {
        for (ctl = _Control; *ctl != 0 &amp;&amp; *ctl != *_String; ctl++)
            ;
        if (*ctl != 0)
        {
            *_String++ = 0;
            break;
        }
    }

    /* Update the context */
    *_Context = _String;

    /* Determine if a token has been found. */
    if (token == _String)
    {
        return NULL;
    }
    else
    {
        return token;
    }
}
</code></pre>
<h3 id="strncpy-s"><a href="#strncpy-s" class="headerlink" title="strncpy_s"></a><code>strncpy_s</code></h3><pre><code class="c++">/***
*tcsncpy_s.inl - general implementation of _tcsncpy_s
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the general algorithm for strncpy_s and its variants.
*
****/

_FUNC_PROLOGUE
errno_t __cdecl _FUNC_NAME(_CHAR *_DEST, size_t _SIZE, const _CHAR *_SRC, size_t _COUNT)
{
    _CHAR *p;
    size_t available;

    if (_COUNT == 0 &amp;&amp; _DEST == NULL &amp;&amp; _SIZE == 0)
    {
        /* this case is allowed; nothing to do */
        _RETURN_NO_ERROR;
    }

    /* validation section */
    _VALIDATE_STRING(_DEST, _SIZE);
    if (_COUNT == 0)
    {
        /* notice that the source string pointer can be NULL in this case */
        _RESET_STRING(_DEST, _SIZE);
        _RETURN_NO_ERROR;
    }
    _VALIDATE_POINTER_RESET_STRING(_SRC, _DEST, _SIZE);

    p = _DEST;
    available = _SIZE;
    if (_COUNT == _TRUNCATE)
    {
        while ((*p++ = *_SRC++) != 0 &amp;&amp; --available &gt; 0)
        {
        }
    }
    else
    {
        _ASSERT_EXPR((!_CrtGetCheckCount() || _COUNT &lt; _SIZE), L&quot;Buffer is too small&quot;);

        while ((*p++ = *_SRC++) != 0 &amp;&amp; --available &gt; 0 &amp;&amp; --_COUNT &gt; 0)
        {
        }
        if (_COUNT == 0)
        {
            *p = 0;
        }
    }

    if (available == 0)
    {
        if (_COUNT == _TRUNCATE)
        {
            _DEST[_SIZE - 1] = 0;
            _RETURN_TRUNCATE;
        }
        _RESET_STRING(_DEST, _SIZE);
        _RETURN_BUFFER_TOO_SMALL(_DEST, _SIZE);
    }
    _FILL_STRING(_DEST, _SIZE, _SIZE - available + 1);
    _RETURN_NO_ERROR;
}
</code></pre>
<h3 id="strncat-s"><a href="#strncat-s" class="headerlink" title="strncat_s"></a><code>strncat_s</code></h3><pre><code class="c++">/***
*tcsncat_s.inl - general implementation of _tcscpy_s
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the general algorithm for strncat_s and its variants.
*
****/

_FUNC_PROLOGUE
errno_t __cdecl _FUNC_NAME(_CHAR *_DEST, size_t _SIZE, const _CHAR *_SRC, size_t _COUNT)
{
    _CHAR *p;
    size_t available;

    if (_COUNT == 0 &amp;&amp; _DEST == NULL &amp;&amp; _SIZE == 0)
    {
        /* this case is allowed; nothing to do */
        _RETURN_NO_ERROR;
    }

    /* validation section */
    _VALIDATE_STRING(_DEST, _SIZE);
    if (_COUNT != 0)
    {
        _VALIDATE_POINTER_RESET_STRING(_SRC, _DEST, _SIZE);
    }

    p = _DEST;
    available = _SIZE;
    while (available &gt; 0 &amp;&amp; *p != 0)
    {
        p++;
        available--;
    }

    if (available == 0)
    {
        _RESET_STRING(_DEST, _SIZE);
        _RETURN_DEST_NOT_NULL_TERMINATED(_DEST, _SIZE);
    }

    if (_COUNT == _TRUNCATE)
    {
        while ((*p++ = *_SRC++) != 0 &amp;&amp; --available &gt; 0)
        {
        }
    }
    else
    {
        _ASSERT_EXPR((!_CrtGetCheckCount() || _COUNT &lt; available), L&quot;Buffer is too small&quot;);

        while (_COUNT &gt; 0 &amp;&amp; (*p++ = *_SRC++) != 0 &amp;&amp; --available &gt; 0)
        {
            _COUNT--;
        }
        if (_COUNT == 0)
        {
            *p = 0;
        }
    }

    if (available == 0)
    {
        if (_COUNT == _TRUNCATE)
        {
            _DEST[_SIZE - 1] = 0;
            _RETURN_TRUNCATE;
        }
        _RESET_STRING(_DEST, _SIZE);
        _RETURN_BUFFER_TOO_SMALL(_DEST, _SIZE);
    }
    _FILL_STRING(_DEST, _SIZE, _SIZE - available + 1);
    _RETURN_NO_ERROR;
}
</code></pre>
<h3 id="strnset-s"><a href="#strnset-s" class="headerlink" title="strnset_s"></a><code>strnset_s</code></h3><pre><code class="c++">/***
*tcsnset_s.inl - general implementation of _tcsnset_s
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the general algorithm for _strnset_s and its variants.
*
****/

_FUNC_PROLOGUE
errno_t __cdecl _FUNC_NAME(_CHAR *_DEST, size_t _SIZE, _CHAR_INT _Value, size_t _COUNT)
{
    _CHAR *p;
    size_t available;

    /* validation section */
    if (_COUNT == 0 &amp;&amp; _DEST == NULL &amp;&amp; _SIZE == 0)
    {
        /* this case is allowed; nothing to do */
        _RETURN_NO_ERROR;
    }
    _VALIDATE_STRING(_DEST, _SIZE);

    _ASSERT_EXPR((!_CrtGetCheckCount() || _COUNT &lt; _SIZE), L&quot;Buffer is too small&quot;);

    p = _DEST;
    available = _SIZE;
    while (*p != 0 &amp;&amp; _COUNT &gt; 0 &amp;&amp; --available &gt; 0)
    {
        *p++ = (_CHAR)_Value;
        --_COUNT;
    }

    if (_COUNT == 0)
    {
        /* ensure the string is null-terminated */
        while (*p != 0 &amp;&amp; --available &gt; 0)
        {
            ++p;
        }
    }

    if (available == 0)
    {
        _RESET_STRING(_DEST, _SIZE);
        _RETURN_DEST_NOT_NULL_TERMINATED(_DEST, _SIZE);
    }
    _FILL_STRING(_DEST, _SIZE, _SIZE - available + 1);
    _RETURN_NO_ERROR;
}
</code></pre>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.cnblogs.com/djzny/p/4476221.html" target="_blank" rel="noopener">C++string函数之strcpy_s</a> 注：该文章中对几个宏的解释存在错误，请甄别阅读</li>
<li><a href="https://bbs.csdn.net/topics/390641877" target="_blank" rel="noopener">strcpy_s的函数实现是啥？</a></li>
</ul>

        
    

    
</div>


                

                <!-- Post Comments -->
                
                    
    <!-- 使用 gitcoment -->
<div id="gitment-comment">
    <!-- Gitment 评论框 -->
<div id="container"></div>
</div>
<style>
    #gitment-comment {
        background-color: #eee;
        padding: 2pc;
    }
</style>
<script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css" />
<script>
    var gitment = new Gitment({
        // id: 'http://www.misteo.top/2020/10/21/安全的字符串拷贝strcpy-s的实现与理解/', // 可选。默认为 location.href
        owner: 'MistEO',
        repo: 'misteo.github.io',
        oauth: {
            client_id: '9daf0aa1bbd84937927e',
            client_secret: 'afc59e71afc8bb1ab612674e377d3e56183c04b9',
        },
    })
    gitment.render('container')
</script>

                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    
        <a href="/2020/11/30/std-unique-ptr使用incomplete-type的报错分析和解决/" id="post_nav-newer" class="prev-content">
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_back</i>
            </button>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            新篇
        </a>
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2018/08/13/散点波形图求峰值面积/" id="post_nav-older" class="next-content">
            旧篇
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(/img/sidebar_header.png);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/avatar.jpeg" alt="MistEO's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        mistereo@hotmail.com
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
                    <a href="mailto:mistereo@hotmail.com" target="_blank" title="Email Me">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        
                        Email Me
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    
        <li id="sidebar-first-li">
            <a href="/">
                
                    <i class="material-icons sidebar-material-icons">home</i>
                
                主页
            </a>
        </li>
        
    

    <!-- Archives  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                    归档
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
            <li>
                <a class="sidebar_archives-link" href="/archives/2020/11/">十一月 2020<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2020/10/">十月 2020<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/08/">八月 2018<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/06/">六月 2018<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/04/">四月 2018<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/03/">三月 2018<span class="sidebar_archives-count">3</span></a>
            </ul>
        </li>
        
    

    <!-- Categories  -->
    

    <!-- Pages  -->
    
        <li>
            <a href="/tags" title="标签">
                
                    <i class="material-icons sidebar-material-icons">chrome_reader_mode</i>
                
                标签
            </a>
        </li>
        
            <li class="divider"></li>
        
    
        <li>
            <a href="/love" title="表白">
                
                    <i class="material-icons sidebar-material-icons">favorite</i>
                
                表白
            </a>
        </li>
        
    
        <li>
            <a href="/links" title="友链">
                
                    <i class="material-icons sidebar-material-icons">people</i>
                
                友链
            </a>
        </li>
        
    
        <li>
            <a href="/about" title="留言">
                
                    <i class="material-icons sidebar-material-icons">message</i>
                
                留言
            </a>
        </li>
        
    

    <!-- Article Number  -->
    
</ul>


        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Sidebar Divider -->
<!--
    <div class="sidebar-divider"></div>
     -->

<!-- Theme Material -->
<!-- 
    <a href="https://github.com/viosey/hexo-theme-material"  class="sidebar-footer-text-a" target="_blank">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
            主题 - Material
            <span class="sidebar-badge badge-circle">i</span>
        </div>
    </a>
 -->

<!-- Help & Support -->
<!--

-->

<!-- Feedback -->
<!--

-->

<!-- About Theme -->
<!--

-->
    </div>

    <!-- Sidebar Image -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div id="back-to-top" class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    

    <!-- Facebook -->
    

    <!-- Google + -->
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    
        <a href="https://github.com/MistEO" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-github">
                <span class="visuallyhidden">Github</span>
            </button><!--
     --></a>
    

    <!-- LinkedIn -->
    

    <!-- Zhihu -->
    
        <a href="https://www.zhihu.com/people/mreo" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-zhihu">
                <span class="visuallyhidden">Zhihu</span>
            </button><!--
     --></a>
    

    <!-- Bilibili -->
    
        <a href="https://live.bilibili.com/2808861" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-bilibili">
                <span class="visuallyhidden">Bilibili</span>
            </button><!--
     --></a>
    

    <!-- Telegram -->
    

    <!-- V2EX -->
    

    <!-- Segmentfault -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©&nbsp;<span year></span>&nbsp;肝！
            
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        -->

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
                <div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
            </div>
        </div>
    
</footer>


                    <!-- Import JS File -->

    <script>lsloader.load("lazyload_js","/js/lazyload.min.js?1BcfzuNXqV+ntF6gq+5X3Q==", true)</script>



    <script>lsloader.load("js_js","/js/js.min.js?Bn9UzEm8RrBSxqyZB0zPjA==", true)</script>



    <script>lsloader.load("np_js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==", true)</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>









   <!-- Gitment -->





<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('<link rel="stylesheet" href="/css/uc.css">');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Import prettify js  -->

    
        
            <script>lsloader.load("prettify_js","/js/prettify.min.js?WN07fivHQSMKWy7BmHBB6w==", true)</script>
        
    



<!-- Window Load -->
<!-- add class for prettify -->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
        
            $(function() {
                $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
                prettyPrint();
                })
        
    
    
</script>

<!-- MathJax Load-->


<!-- Bing Background -->


<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Custom Footer -->



<script>
    var copyrightNow = new Date().getFullYear();
    var textContent = document.querySelector('span[year]')

    copyrightSince = 0000;
    if (copyrightSince === copyrightNow||copyrightSince === 0000) {
        textContent.textContent = copyrightNow
    } else {
        textContent.textContent = copyrightSince + ' - ' + copyrightNow
    }

    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.5.6 | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
        </body>
    
</html>
